<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Rust|Package,Crate,Module</title>
      <link href="/2023/02/22/23-08-23/"/>
      <url>/2023/02/22/23-08-23/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-rust代码组织"><a class="markdownIt-Anchor" href="#1-rust代码组织"></a> 1. Rust代码组织</h2><p>代码组织可以决定哪些细节可以暴露，哪些细节是私有的，作用域内哪些名称有效。。。</p><p>模块系统：</p><ul><li><strong>package（包）</strong>：cargo特性，让你构建、测试、共享crate</li><li><strong>crate（单元包）</strong>：一个模块数，它可以产生一个library或可执行文件</li><li><strong>module（模块）、use</strong>：让你控制代码的组织、作用域、私有路径</li><li><strong>path（路径）</strong>：为struct、function或module等命名的方式</li></ul><p><img src="https://img2020.cnblogs.com/blog/27612/202111/27612-20211106113206098-804387811.png" alt="代码组织" /></p><h2 id="11-package和crate"><a class="markdownIt-Anchor" href="#11-package和crate"></a> 1.1 package和crate</h2><p>对于一个package，有以下规定：</p><ul><li>包含一个Cargo.toml，它描述了如何构建这些crates</li><li>最多包含一个library crate</li><li>可以包含任意数量的binary crate</li><li>至少包含一个crate（library或binary）</li></ul><p>crate有两种类型：binary和library，有一个crate root，是源代码文件，Rust编译器从这里开始，组成crate的根module</p><h2 id="12-cargo的惯例"><a class="markdownIt-Anchor" href="#12-cargo的惯例"></a> 1.2 cargo的惯例</h2><p>创建一个新的Rust项目，命名为<code>my-project</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo new my-project</span><br></pre></td></tr></table></figure><p>出现文件<code>src/main.rs</code>，该文件是binary crate的crate root，crate名与package名相同</p><p>若出现<code>src/lib.rs</code>（一般不会），该文件表示package包含一个library crate，其为library crate的crate root，crate名与package名相同</p><p>cargo把crate root文件交给rustc来构建library或binary</p><p>一个package可以同时包含<code>src/main.rs</code>和<code>src/lib.rs</code>，名称与package名相同。一个package可以同时有多个binary crate，文件必须放在<code>src/bin</code>中，每个文件是单独的binary crate</p><h2 id="13-定义module来控制作用域和私有性"><a class="markdownIt-Anchor" href="#13-定义module来控制作用域和私有性"></a> 1.3 定义module来控制作用域和私有性</h2><p>使用module有以下好处：</p><ul><li>在crate内，将代码进行分组</li><li>增加可读性，易于复hexo</li><li>控制项目（item）的私有性（public、private）</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>()&#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mod</span> serving</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>()&#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>()&#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-path路径"><a class="markdownIt-Anchor" href="#2-path路径"></a> 2. Path路径</h2><p>为了在Rust的模块中找到某个条目，需要使用<strong>路劲</strong>。</p><p>路径有两种形式：</p><ul><li><strong>绝对路径</strong>：从crate root开始，使用crate名或字面值crate</li><li><strong>相对路径</strong>：从当前模块开始，使用self，super或当前模块的标识符</li></ul><p>路径至少由一个标识符组成，标识符之间使用<code>::</code></p><p>以下例子来自文件<code>src/lib.rs</code>，即拥有lib crate root</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waiting</span>()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at</span> <span class="title function_ invoke__">restaurant</span>()</span><br><span class="line">&#123;</span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();<span class="comment">//绝对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();<span class="comment">//相对路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-privacy-boundary私有边界"><a class="markdownIt-Anchor" href="#21-privacy-boundary私有边界"></a> 2.1 Privacy Boundary私有边界</h3><p>模块不仅可以组织代码，还可以定义私有边界。如果想把<code>函数</code>或者<code>struct</code>等设为私有，可以将它放在某个模块中。定义规则：</p><ul><li>Rust中的所有条目（函数，方法，struct，enum，模块，常量）默认是私有的。</li><li>父级模块无法访问子模块中的私有条目。</li><li>子模块可以使用所有祖先条目。</li><li>同级条目可以互相访问。</li><li>使用<code>pub</code>关键字，将条目标记为公共。</li></ul><h3 id="22-super关键字"><a class="markdownIt-Anchor" href="#22-super关键字"></a> 2.2 <code>super</code>关键字</h3><p>利用<code>super</code>关键字来访问父级模块路径中的内容，类似文件系统中的<code>..</code></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">server_order</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        super::<span class="title function_ invoke__">server_order</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-pub-struct和pub-enum"><a class="markdownIt-Anchor" href="#23-pub-struct和pub-enum"></a> 2.3 <code>pub struct</code>和<code>pub enum</code></h3><p>pub放在struct前，struct变为公共的，但是struct的字段还是默认私有的；struct的字段需要单独设置<code>pub</code>来变成共有的。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Breakfast</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast:<span class="type">String</span>,</span><br><span class="line">        seasonal_fruit:<span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Breakfast</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">summer</span>(toast:&amp;<span class="type">str</span>)<span class="punctuation">-&gt;</span>Breakfast</span><br><span class="line">        &#123;</span><br><span class="line">            Breakfast</span><br><span class="line">            &#123;</span><br><span class="line">                toast:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(toast),</span><br><span class="line">                seasonal_fruit:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">meal</span> = back_of_house::Breakfast::<span class="title function_ invoke__">summer</span>(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    meal.toast = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Wheat&quot;</span>);</span><br><span class="line">    meal.seasonal_fruit = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;blueberries&quot;</span>);<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pub放在enum前，<strong>enum是公共的，里面的变体也是公共的</strong>。</p><h2 id="3-use关键字"><a class="markdownIt-Anchor" href="#3-use关键字"></a> 3. <code>use</code>关键字</h2><p>可以使用<code>use</code>关键字将路径导入作用域中，仍然遵循私有性规则。</p><p>相对路径、绝对路径都可以</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>()</span><br><span class="line">&#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="31-use的习惯用法"><a class="markdownIt-Anchor" href="#31-use的习惯用法"></a> 3.1 use的习惯用法</h3><ul><li><p>函数：针对函数一般引入其父模块，防止函数重名情况（父级）</p></li><li><p>struct，enum：指定完整路径（本身）</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;<span class="comment">//结构体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同名条目：父级，比如两个定义在不同模块的同名struct，要指定到父级</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f1</span>() <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f2</span>()<span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;&#125;</span><br></pre></td></tr></table></figure><p>也可以使用<code>as</code>关键字，为引入的路径指定本地的别名</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f2</span>()<span class="punctuation">-&gt;</span> IoResult&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="32-使用pub-use重新导入名称"><a class="markdownIt-Anchor" href="#32-使用pub-use重新导入名称"></a> 3.2 使用<code>pub use</code>重新导入名称</h3><p>使用<code>use</code>将路径导入到作用域内后，该名称在此作用域内私有，<code>pub use</code>重导出，将条目引入作用域，该条目可以被外部代码引入到它们的作用域</p><h3 id="33-使用外部包package"><a class="markdownIt-Anchor" href="#33-使用外部包package"></a> 3.3 使用外部包（package）</h3><p>cargo.toml添加依赖的包（package）</p><p>标准库（std）也被当做外部包，但是不需要修改cargo.toml添加，需要使用use将std中特定的条目引入当前作用域</p><h3 id="34-使用嵌套路径清理大量的use语句"><a class="markdownIt-Anchor" href="#34-使用嵌套路径清理大量的use语句"></a> 3.4 使用嵌套路径清理大量的use语句</h3><p>可以使用嵌套路径在同一行内将同一个包或模块下的多个条目进行引入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">路径相同的部分::&#123;路径差异的部分&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std ::io;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">use::std::&#123;cmp::Ordering,io&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Writing;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>,Writing&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="35-通配符"><a class="markdownIt-Anchor" href="#35-通配符"></a> 3.5 通配符<code>*</code></h3><p>可以使用通配符<code>*</code>将某个模块下的所有条目引入，但是要谨慎使用。使用场景：</p><ul><li>测试，将所有被测试代码引入到tests模块</li><li>有时被用于预导入（prelude）模块</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust|所有权</title>
      <link href="/2023/02/17/21-41-06/"/>
      <url>/2023/02/17/21-41-06/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1什么是所有权"><a class="markdownIt-Anchor" href="#1什么是所有权"></a> 1.什么是所有权</h2><p><strong>所有权</strong>是Rust的核心特性，它让Rust不需要GC（垃圾收集器）就可以保证内存安全。</p><p>所有的程序在运行时都必须管理它们使用计算机内存的方式。有些语言（C#，java）有垃圾收集机制，在程序运行时，它们会不断地寻找不再使用的内存；有些语言（C、C++），程序员必须显式分配和释放内存。</p><p>Rust采用第三种方式：内存通过一个所有权管理系统管理，其中包含一组编译器在编译时检查的规则。当程序运行时，所有权特性不会减缓程序运行速度，因为Rust把内存管理相关工作提前到编译时。</p><h3 id="11-stack-vs-heap栈内存vs堆内存"><a class="markdownIt-Anchor" href="#11-stack-vs-heap栈内存vs堆内存"></a> 1.1 Stack vs Heap（栈内存vs堆内存）</h3><p>对于Rust，一个值存储在栈上还是堆上，对语言行为和你要做的某些决定有更大的影响。</p><p>在代码运行时，stack和heap都是可用的内存，但是它们的结构不一样。</p><ul><li><strong>存储数据</strong></li></ul><p>stack后进先出，LIFO，添加数据叫压入栈，移除叫弹出栈。</p><p>所有存储在stack上的数据必须拥有已知的固定的大小，编译时大小未知的数据或运行时大小可能发生变化的数据必须存放在heap上。</p><p>当你把数据放入heap时，你会请求一定数量的空间；操作系统在heap里找到足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址。这个过程叫做在heap上进行分配，有时仅仅称为“分配”。</p><p>把值压在stack上就不叫分配。因为操作系统不需要寻找用来存储新数据的空间，那个位置永远在stack的顶端。把数据压在stack上要在heap上分配快的多。在heap上分配空间需要做更多的工作，操作系统首先要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配。</p><ul><li><strong>访问数据</strong></li></ul><p>访问heap上的数据要比访问stack上的数据慢，因为需要通过指针才能找到heap中的数据。如果指令在内存中跳转次数越少，那么速度越快。</p><p>stack上数据存放距离比较近，处理起来快一些。</p><p>heap上数据之间距离比较远，处理速度慢一些。此外在heap上分配大量空间也需要时间。</p><ul><li><strong>函数调用</strong></li></ul><p>当代码调用函数时，值被传入到函数（包括指向heap的指针）。函数本地的变量被压到stack上。函数结束后，这些值会从stack上弹出。</p><ul><li><strong>所有权存在的原因</strong></li></ul><p>管理heap数据是所有权存在的原因，这有助于解释它为什么会这样工作。</p><p>所有权解决的问题：</p><ol><li>跟踪代码的哪些部分正在使用heap的哪些数据；</li><li>最小化heap上的重复数据量；</li><li>清理heap上未使用的数据避免空间不足。</li></ol><p>这样就可以不经常去想stack和heap了。</p><h3 id="12-所有权规则"><a class="markdownIt-Anchor" href="#12-所有权规则"></a> 1.2 所有权规则</h3><ol><li>每个值都有一个变量，这个变量是这个值的所有者；</li><li>每个值同时只能有一个所有者；</li><li>当所有者超出作用域（scope）时，该值将被删除；</li></ol><ul><li><strong>变量作用域</strong></li></ul><p>scope就是程序中的一个项目的有效范围，这一点和其他语言都类似。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br><span class="line">&#123;   <span class="comment">//s不可用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;<span class="comment">//s可用</span></span><br><span class="line">    <span class="comment">//可以对s进行相关操作</span></span><br><span class="line">&#125;<span class="comment">//s作用域到此结束，s不再可用</span></span><br></pre></td></tr></table></figure><ul><li><strong>string类型</strong></li></ul><p>string存储在heap上，比基础标量数据类型更复杂。</p><p>在Rust中有字符串字面值，即程序里手写的字符串，它们是不变的，为了编译未知数量的文本，Rust采用string类型。</p><p>可以使用<code>from</code>函数从字符串字面值创建出string类型</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//::表示from是String类型下的函数</span></span><br></pre></td></tr></table></figure><p>这类字符串是可以被修改的。</p><h3 id="13-内存与分配"><a class="markdownIt-Anchor" href="#13-内存与分配"></a> 1.3 内存与分配</h3><p>字符串字面值，在编译时就知道它的内容了，其文本内容直接被硬编码到最终的可执行文件里。速度快、高效，是因为<strong>其不可变性</strong>。</p><p>String类型，为了支持可变性，需要在heap上分配内存来保存编译时未知的文本内容。当用完String后，需要某种方式将内存返回给操作系统，这一步，在拥有GC的语言中，GC会跟踪并清理不再使用的内存，没有GC就要我们识别内存何时不再使用，并调用代码将它返回。如果忘了，就浪费内存；如果提前做了，变量就变得非法；如果做了两次，就是double free bug，必须一次分配对应一次释放。</p><p>Rust采用了不同的方式：对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动交还给操作系统，走出作用域时调用<code>drop</code>函数。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;,world&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>变量和数据交互的方式：移动（move）</strong></li></ul><p>多个变量可以与同一个数据使用同一种独特的方式来交互，如</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure><p>整数是已知大小且固定大小的简单的值，这<strong>两个5</strong>被压到stack中。</p><p>如果类型是String，它由三个内容组成，一个指向存放字符串内容的内存的指针；一个长度<code>len</code>，就是存放字符串内容所需的字节数；一个容量<code>capacity</code>，值String从操作系统中总共获得内存的总字节数。具体如下。</p><p><img src="https://s2.loli.net/2023/02/08/78ZpduTIRVaLBPs.png" alt="String类型组成" /></p><p>左边存放在stack，右边存放在heap。</p><p>当出现如下情况：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure><p>对于一般情况，String的数据会被复制一份。在stack上复制一份指针、长度、容量，并没有复制heap上的数据。当变量离开作用域时，Rust自动调用<code>drop</code>函数，释放heap内存，这会导致doouble free bug。</p><p><img src="https://s2.loli.net/2023/02/09/2LqxrDfckbat4TB.png" alt="s1赋值给s2" /></p><p>为了保证内存安全，Rust没有尝试复制被分配的内存，Rust让s1失效，s1离开作用域时，Rust不需要释放任何东西。这里，我们用一个新的术语：移动（move）。</p><p>这里隐含一个<strong>设计原则</strong>：Rust不会自动创建数据的深拷贝，就运行时的性能而言，任何自动赋值的操作都是廉价的。</p><ul><li><strong>变量和数据交互的方式：克隆（clone）</strong></li></ul><p>如果真想实现深拷贝，就要用克隆，如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,s1,s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/09/FlpdirOARHcyt2P.png" alt="clone" /></p><p>比较消耗资源。</p><ul><li><strong>stack上的数据：复制</strong></li></ul><p>Rust提供copy trait（可以理解为一个接口），可以用于像整数这样完全存放在stack上面的类型。如果一个类型实现了copy trait，那么旧的变量在赋值后仍然可用。但是一个类型或者该类型的一部分实现了drop trait，那么Rust不允许让他再去实现copy trait了。</p><p>一些拥有copy trait的类型：</p><p>所有整数类型，如<code>u32</code></p><p>bool</p><p>char</p><p>所有浮点类型，如<code>f64</code></p><p>任何需要分配内存或某种资源的都不是copy的</p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>岁末的信2022</title>
      <link href="/2022/12/31/19-01-34/"/>
      <url>/2022/12/31/19-01-34/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-cuJxejds" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1457549896" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>诚然，大多数人能吃饱，然后吃好，偶尔还能吃出点花样，不过是近十几年间的事情。</p><p>我的家乡没什么好吃的，我妈也做不出花样，但也不至于把我饿着。 夏天丝瓜，冬天青菜，总是霸占着餐桌。每天吃差不多的菜，四季轮回，这是生活常态。</p><p>小时候考了一百分，我妈就带我出去吃炸鸡腿，吃漂着辣油的豆腐脑，吃兰州牛肉拉面。对我来说，这就是天大的事情。</p><p>过年回外婆家，吃每家都会有的粉蒸肉、灌肠，吃鸡鸭鹅汤，吃两条谁都不敢动筷子的鱼。外婆外公不停给我夹菜，我的碗从没空过。我就偷偷把肉扔到地上，喂猫。我们过年，家里的老猫也胖了。</p><p>外婆总在操心做什么菜，对她来说，做饭就是头等大事。我从来不操心，因为桌子上总有我喜欢的菜，我从来没有体会过饥饿的滋味。在外婆家的桌子上，我深切地相信，日子是越来越好的。</p><p>后来，外公生了病。那年除夕，大舅家、小舅家，我们一家终于聚齐，那个桌子太大了，桌上的菜太多了。外公看着我们，只是喝点汤，再难吃下其他东西。我想，不怕，外公的病会好，菜也总在。</p><p>谁知一日轻佻，日后遗憾无尽。</p><p>上了高中，晚自习下课已经接近十一点。那段时间压力真大，回家没好气，不想说话。我妈就给我煮面，下小馄饨，切水果，看着我吃。她总问我明晚吃什么，仿佛明晚吃什么就是最重要的事。我吃完面条，两手一摆，随便吧，就回房间了。</p><p>倏忽上了大学，今年年初，我们因为疫情封在宿舍。两层食堂只有寥寥几个快餐窗口开放。我们拎着饭盒，跟着漫长的队伍打饭。每天趁着做核酸，我和QQ就会去超市排队，可是超市也是空的，货架上空空荡荡。第一次，我体会到对食物的焦虑。</p><p><img src="https://s2.loli.net/2022/12/31/SBQ9ixq7oPIMs3p.png" alt="老师的微信截图" /></p><p>这年，我们大部分时间被封在学校。吃播几乎承载了我对美好食物的向往。我想起儿时的炸鸡腿，想起妈妈煮的面，想起外公外婆的年夜饭。</p><p>红尘颠倒，无情至此。</p><p>不想挨饿，但同时，一种具体而形而上的饿又困扰着我。</p><p>疫情年代，我和舍友在宿舍吃泡面，品尝饥饿。仿佛兜兜转转，一切重来。</p><p>吃饱吃好，永远是天大的事情。</p><p><img src="https://s2.loli.net/2022/11/11/AeFHqSL59dDZcNB.png" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家 </tag>
            
            <tag> 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈|新冠日记</title>
      <link href="/2022/12/25/14-44-19/"/>
      <url>/2022/12/25/14-44-19/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-SpkhoszK" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1300885683" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>简单记录我和QQ感染阶段的身心状况、用药情况和所思所感。</p><h2 id="我的日记"><a class="markdownIt-Anchor" href="#我的日记"></a> 我的日记</h2><mark class="hl-label blue">12月21日前</mark> <p>回家之后，我时不时在宿舍群问问。大家好像都还坚挺。</p><img src="https://s2.loli.net/2022/12/25/wktzKHuch7iFMJy.jpg" alt="聊天截图" style="zoom:20%;" /><mark class="hl-label blue">17号</mark> 我妈感冒了，流鼻涕、嗓子疼，但没发烧，晚上她单独睡。<mark class="hl-label blue">18号</mark> 她的感冒症状依旧，但是依然没发烧，测了新冠唾液检测，阴性，又上班去了。<mark class="hl-label blue">20号中午</mark> ，我爸开始发烧，嗓子疼，他熬了姜汤，吃了一粒布洛芬就昏昏欲睡了。晚上测温，38.6℃，又吐了两次。当时感觉有点不妙，完全符合新冠症状。第二天早上他退烧，测了新冠唾液检测，竟然是阴性。现在想来，应该是唾液检测的误差太大，我爸我妈应该都感染了，只是我妈症状轻微。<img src="https://s2.loli.net/2022/12/25/wiORU542dCvhapf.jpg" alt="新冠唾液检测和抗原检测" style="zoom:30%;" /><p>图片里上面一包saliva test是新冠唾液检测，低头含在舌下就可以；下面一包是常见的鼻拭子抗原检测，以后还是多备点鼻拭子的吧，唾液检测一点也不准:(</p><mark class="hl-label blue">12月22日</mark> <p>一觉起来，我连打五六七八个喷嚏，喉咙有点不适，吃饭的时候我妈问我是不是熬夜玩手机了，眼睛好红。原来是熬夜玩手机玩的，我还以为阳了呢:)</p><p>晚上又开始连打喷嚏，我喝了包风寒感冒颗粒（现在才知道这药没用）就上床了。在床上好冷，浑身不住地颤抖，凌晨1:30开始发热，浑身滚烫，被子都掀了，测温38℃，吃了一粒布洛芬，等待药效起效的过程中，两腿酸痛，被子盖在身上有如千斤，翻身都很吃力。大概过了一个多小时，感觉布洛芬起了作用，慢慢入睡了。</p><mark class="hl-label blue">12月23日</mark> <p>早上头疼，鼻塞，腿酸痛，测了体温36.7摄氏度，退烧了。做了鼻拭子抗原检测，确定是阳了。</p><img src="https://s2.loli.net/2022/12/25/Xq5osOvgxFTiMwJ.jpg" alt="阳了" style="zoom: 25%;" /><p>折磨才刚刚开始。</p><p>起床之后腿是软的，腰也酸痛。动作稍微迅速一点就头晕。</p><p>晚上上床，和昨天一样冷得发抖，害怕复烧，我吃了一粒布洛芬。浑身难受，入睡困难，药效起了才舒服点。睡梦中又觉得时冷时热，梦里仿佛悲辛尝尽，过了一个世纪，醒来一看凌晨三点，就睡不着了。鼻塞，口干，用嘴呼吸，嘴巴干到起皮。</p><mark class="hl-label blue">12月24日</mark> <p>症状相比昨天差不多，鼻塞之后说话像丁真+丽丽。</p><p>看了COVID-19治疗手册，上面说轻症无需特殊治疗，根据需要对症下药。</p><blockquote><p>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzA3NjAzOTk5OQ==&amp;mid=2651929542&amp;idx=1&amp;sn=8b6c67ded4aa0df75eb0d99b99f3ad87&amp;chksm=8482c996b3f5408071453a4d9d01a337f911f4363ec55817d8de8d33abed05ee89a16826fd90&amp;mpshare=1&amp;scene=1&amp;srcid=1225ldlNQaULZuytG5xaJ25F&amp;sharer_sharetime=1671972490925&amp;sharer_shareid=fdd73e407b0d23d4b49cdd787d7ad251#rd">中国医科大学大学校友会公众号</a></p></blockquote><p>晚上在厕所，腿软，差点摔死。睡前吃了几粒连花清瘟胶囊，吃了感觉喉咙到胃很清凉，看来确实起到了缓解症状的效果。依然难以入眠，但是腿不那么疼了，切实感觉身体在好转。</p><mark class="hl-label blue">12月25日</mark> <p>今天起床感觉轻松一大截，还是鼻塞，测了抗原，竟然不是阳性了。</p><img src="https://s2.loli.net/2022/12/25/59DwALFPzQRpagq.jpg" alt="阴性" style="zoom:25%;" /><p>快点好起来吧。</p><h2 id="qq的日记"><a class="markdownIt-Anchor" href="#qq的日记"></a> QQ的日记</h2><div class="note info simple"><p>编者按：QQ比我提前几天感染新冠，她写了一篇名为《新冠我***》的日记，现以时间线的形式整理如下</p></div><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-20</p></div></div><div class='timeline-item-content'><p>开始嗓子不舒服</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-21</p></div></div><div class='timeline-item-content'><p>烧了一天，喉咙好疼，浑身没有力气，脑袋也好疼</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-22</p></div></div><div class='timeline-item-content'><p>烧退了，感觉好了很多，但还是有点疲惫，头还是疼，嗓子也疼</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-23</p></div></div><div class='timeline-item-content'><p>开始出现更多像感冒的症状，鼻塞，小咳嗽，有痰吐不出来。寒寒也中招了。我们竟然有相同的症状。鼻子水泄不通，难以入睡，头疼得厉害，不能用力，上厕所一用力头就疼，走路一振，头就疼。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-24</p></div></div><div class='timeline-item-content'><p>头疼占主流，晕乎乎的，鼻子还是不畅通，转移注意力，看了一集跑男。头真的太疼了。晚上上床整个人哆嗦，电热毯反反复复开了好多次，明天我一定要烧个热水袋！鼻子塞了可怎么睡得着觉啊！请问把鼻子割掉了可以呼吸吗，如果可以我愿意。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-25</p></div></div><div class='timeline-item-content'><p>凌晨真的想要撞墙，鼻子塞住了一个，能呼吸的那一个像充血一样，超级疼，不想呼吸了，如果可以不呼吸就好了。感觉自己呼吸都是错的。尝试用嘴呼吸，喉咙就干的快要裂了，嘴唇也毛毛躁躁红了一圈。用力擤鼻子，终于两个全塞住了。睡醒了嘴里好干，想要喝水，但爬不起来。十一点爬起来吃午饭，味同嚼蜡。米饭太硬了，每咽一口就像是要刀割一次喉咙。</p></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++|可变参数与void指针</title>
      <link href="/2022/11/30/11-31-29/"/>
      <url>/2022/11/30/11-31-29/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h2><p>可变参数是指函数的参数的数据类型和数量都是不固定的。</p><p>例如<code>printf()</code>函数的参数就是可变的。这个函数的原型是：<code>int printf(const char *format,...)</code></p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> count, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello I am foo\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    va_list parameters;<span class="comment">//va_list变量</span></span><br><span class="line">    va_start(parameters,count);<span class="comment">//初始化,count是形参个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">void</span>* parameter = va_arg(parameters,<span class="type">void</span>*);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,(<span class="type">int</span>*)parameter);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_end(parameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>定义</strong></li></ul><p>一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</p><ul><li><code>va_list </code></li></ul><p>在函数定义中创建一个 <code>va_list </code>类型变量，该类型是在 <code>stdarg.h </code>头文件中定义的。它包含了参数信息，这种类型的对象也被称为<strong>参数指针</strong>。它包含了栈中至少一个参数的位置，可以使用它从一个可选参数到下一个。</p><ul><li><code> va_start</code></li></ul><p>使用 int 参数和<code> va_start</code> 宏来初始化 <code>va_list</code> 变量为一个参数列表。宏 <code>va_start</code> 是在<code>stdarg.h</code>头文件中定义的。宏 <code>va_start</code> 使用第一个可选参数的位置来初始化 <code>va_list</code> 参数指针。该宏的第二个参数必须是该函数最后一个有名称参数的名称。必须先调用该宏，才可以开始使用可选参数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_start</span><span class="params">(va_list argptr, lastparam)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>va_arg</code></li></ul><p>使用 <code>va_arg</code> 宏和<code>va_list</code>变量来访问参数列表中的每个项。展开宏 <code>va_arg</code> 会得到当前参数指针所引用的可选参数，也会将参数指针移动到列表中的下一个参数。宏 <code>va_arg</code> 的第二个参数是刚刚被读入的参数的类型。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="title function_">va_arg</span><span class="params">(va_list argptr, type)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>va_end</code></li></ul><p>使用宏 <code>va_end</code> 来清理赋予 <code>va_list</code> 变量的内存。当不再需要使用参数指针时，必须调用宏 <code>va_end</code>。如果想使用宏 <code>va_start</code> 或者宏 <code>va_copy</code> 来重新初始化一个之前用过的参数指针，也必须先调用宏 <code>va_end</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_end</span><span class="params">(va_list argptr)</span>;</span><br></pre></td></tr></table></figure><h2 id="void"><a class="markdownIt-Anchor" href="#void"></a> void*</h2><p><code>void</code>被翻译为“无类型”，相应的<code>void*</code>为“无类型指针”。</p><p><code>void*</code>指针变量可以指向任意变量的内存空间，任意类型指针变量都可以转换为<code>void*</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>* p = &amp;num;</span><br><span class="line"><span class="type">int</span>* p_num = &amp;num;</span><br><span class="line"><span class="type">void</span>* p1 = p_num;</span><br></pre></td></tr></table></figure><p>对于<code>void*</code>指针变量，不要解除引用操作，如果想通过指针变量p获取num的值，需要强制类型转换</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p_num = (<span class="type">int</span>*)p;</span><br><span class="line">cout&lt;&lt; *p &lt;&lt;endl;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C\C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈|人生的必经之路？</title>
      <link href="/2022/11/27/17-51-32/"/>
      <url>/2022/11/27/17-51-32/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这周天，我担任了2020级网信院发展对象谈话面试官，与其他四位同志共同面试了25位积极分子。我不希望把这次活动看成“面试”，这只是一个有时间规定的谈话活动。我也不喜欢打分，打分是出于一些不得不遵守的规定，我知道，冰冷的分数不能代表我们思想的火花。从学生的角度来说，我们都是平等的。</p><p>与诸君交流，收获良多，简单记录如下。也想借此契机谈谈向组织靠拢的过程中、在我们成长的关键时期，可以警惕，可以反思的思维倾向。</p><h2 id="陈言套语的套用"><a class="markdownIt-Anchor" href="#陈言套语的套用"></a> 陈言套语的套用💢</h2><p>许多同学都喜欢说套话、说官话。我们生活在这种环境中，这是正常的，但也是不对的。拿我自己举例，高中写作文没题目，就写在时代中坚守，在传统中创新。大一大二写思想汇报，想不到词就写“巩固了、夯实了、扩大了，武装头脑、指导实践、深入贯彻”。现在读论文，积累黑话，没有思路就写“显然可以得知”，缺乏转折就写“有意思的是”，用了excel就写“通过推演运算，加上广泛的数字化可视数据”。</p><p>有错吗，当然不。甚至有些人连套话都说不出来，至少面试的大多数同学都愿意背一些。但是扪心自问，孱弱吗，苍白吗，值得深入挖掘意义吗。我们的时代在发展，语境也会不同。“陈言务去”，希望我们都能有自己的想法，在不同的时代，找到属于自己的阐释空间。</p><h2 id="空而无物的叙述"><a class="markdownIt-Anchor" href="#空而无物的叙述"></a> 空而无物的叙述❗</h2><p>或许是高中写作思维的桎梏，一些同学的叙述往往太空泛。比如“对xx有了更深刻的认识”，那么“认识”是什么，讲不清，意义不明。比如说自己从小被组织的事业感染引领，感恩自己生活在好时代，需要砥砺前行，那么是什么事业，怎样被感染，怎样做的，说不出所以然。</p><p>空泛的言语透露空洞的思想。看不出对周围事物的关切，也没现实的思考。单靠情绪与形容词来组织语言，是一种“讨巧”的方法，反而会弄巧成拙。谈话短短五分钟，从身边切入，从小事入手。能够给人感动的，不是“伟大光荣正确”，而是雪后的阳光，是同志温暖的握手，是书院记得我们所有人的生日。</p><h2 id="真诚才是必杀技️"><a class="markdownIt-Anchor" href="#真诚才是必杀技️"></a> 真诚才是必杀技❤️</h2><p>短短五分钟的谈话，要给几个完全不认识的人剖析内心，袒露思想，太难了。除非有过系统化的培训，不然临时背诵、编篡、组织都容易露怯。最简单也是最好的方法，是真诚。因为说谎话太难了，需要天赋。</p><p>给我印象最深的同学来自新疆，ta讲述了父亲守边的故事。故事里有一米厚的大雪，有风雪中的牛羊。ta又谈到家乡的疫情，提到对政策毫无保留的支持，同时也谈到家乡人民的善良、勇敢与无奈。我相信ta的讲述都是亲身经历的，是真切的。ta没有把话“说得很漂亮”，但是至少，言之有物、信源准确、辩证开放。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>想起一位同学说，入党是人生必须走的路。由此可见，思维深处，我们也许对某些高大上的概念，对我们的党，形成了一个固化的认知结构。人生有很多路，它们通向真理、勇敢、善良、自由，但是没有路是“必须的”，只要你真心向往，路都是殊途同归的。</p><p>这些既是我看到的问题，也是我对自己的要求。虽然我也没有完全做到，但我依然为此砥砺。</p><p>共勉。</p><img src="https://s2.loli.net/2022/11/29/M3BvAbtp25Yqk1L.png" alt="image-20221129174934576" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLVM|LLVM入门的入门</title>
      <link href="/2022/11/16/17-50-25/"/>
      <url>/2022/11/16/17-50-25/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><a href="https://llvm.org/docs/ProgrammersManual.html#introduction">https://llvm.org/docs/ProgrammersManual.html#introduction</a></p><p><a href="https://llvm.org/docs/LangRef.html">https://llvm.org/docs/LangRef.html</a></p><p>2022年11月16日</p><p>❤️</p></blockquote><h2 id="0前言"><a class="markdownIt-Anchor" href="#0前言"></a> 0.前言</h2><p>对程序进行分析，不管是静态还是动态，都需要插桩。从LLVM入手插桩很方便，师兄花了很长时间研究，实验室只有他孤军奋战、苦苦求索，备受孤独与迷茫的双重煎熬。导师坦言担心他的精神状态。</p><p>之后，师兄每周给我们开小灶，进行鞭挞😢</p><p>之所以称为入门的入门，是因为我还没真正入门😄</p><p>我还不能系统地写明LLVM的种种，本文只对其进行简要介绍，引导志同道合的朋友。同时，在前面的引用奉上官方文档，希望共同进步。</p><h2 id="1llvm简介"><a class="markdownIt-Anchor" href="#1llvm简介"></a> 1.LLVM简介</h2><p>编译原理把编译过程分为前后端：</p><ul><li>前端把源代码翻译成中间表示（IR）</li><li>后端把IR编译成目标平台的机器码。当然IR也可以直接给解释器解释执行。</li></ul><p>经典的编译器如<code>gcc</code>在设计上提供一条龙服务，即我们不需要知道它的IR是什么，它也不提供接口给我们来操作其IR。这种做法有好有坏。好处是从前端到后端，这些编译器的代码强耦合，可以在内部做任何想做的优化。坏处是，每当一个新平台出现，这些编译器都要各自为政实现一个从IR到新平台的后端。如果出现一种新语言，那么可能就需要实现一个新的编译器，重新设计一个新的IR。如果有M种新语言，N种新平台，那么最坏的情况下，需要实现M*N个前后端，比较低效。</p><p>为此，我们希望有一种共用的IR，每当有一种新语言，就添加其到IR的前端，每当有一个新平台，就添加其到IR的后端。如果有M种新语言，N种新平台，最优情况下我们只需要实现M+N个前后端。</p><p>LLVM就是这样一个项目。LLVM的核心设计了一个叫LLVM IR的中间表示，并以库的方式提供一系列接口，提供各种功能。</p><h2 id="2clang简介"><a class="markdownIt-Anchor" href="#2clang简介"></a> 2.Clang简介</h2><p>Clang是一个基于LLVM的编译器驱动，它提供把C/C++/OC等语言翻译成LLVM IR的前端，并使用LLVM的库实现LLVM IR到目标平台的后端。</p><p>叫编译器驱动是因为使用<code>clang main.c -o main</code>（Clang兼容gcc语法）的时候，Clang帮我们“驱动”C语言预处理器，C语言前端，LLVM后端，链接器等等。其实GUN gcc也是编译器驱动。为了方便，我们习惯称为编译器。</p><p>一般我读Clang为/see-lang/，但是其实很多人读/klang/，哈哈。</p><h2 id="3llvm-irintermediate-representation"><a class="markdownIt-Anchor" href="#3llvm-irintermediate-representation"></a> 3.LLVM IR(Intermediate Representation)</h2><p>LLVM的中间表⽰，本质上⼀种与源编程语⾔和⽬标机器架构⽆关的通用中间表⽰</p><p>LLVM IR是⼀种类似于RISC的低级虚拟指令集</p><p>LLVM是使⽤简单类型系统的强类型(例如， <code>i32</code>是⼀个32位整数， <code>i32*</code>是指向32位</p><p>整数的指针)</p><p>LLVM IR 不使用一组固定的命名寄存器,它使⽤⼀个名为%字符的无限临时集合</p><p>LLVM IR代被设计成三种不同的形式：内存编译器IR，磁盘⼆进制<code>.bc</code> 表⽰(适合于即时编</p><p>译器的快速加载)，可读的汇编语⾔<code>.ll</code></p><h3 id="31-ir结构"><a class="markdownIt-Anchor" href="#31-ir结构"></a> 3.1 IR结构</h3><p>Module（模块）是⼀份LLVM IR的顶层容器，对应于编译前端的每个翻译单元（TranslationUnit）。每个模块由⽬标机器信息、全局符号（全局变量和函数）及元信息组成。</p><p>Function（函数）就是编程语⾔中的函数，包括函数签名和若干个基本块，函数内的第⼀个基本块叫做入口基本块。</p><p>BasicBlock（基本块）是⼀组顺序执⾏的指令集合，只有<strong>⼀个入口和⼀个出口</strong>，非头尾指令执行时不会违背顺序跳转到其他指令上去。每个基本块最后⼀条指令⼀般是跳转指令（跳转到其它基本块上去），函数内最后⼀个基本块的最后条指令是函数返回指令。</p><p>Instruction（指令）是LLVM IR中的最小可执行单位，每⼀条指令都单占一行</p><p>一个Module中可以有n个Function，Function内可以有n个BasicBlock，BasicBlock是单进单出的n条Instruction序列。</p><img src="https://s2.loli.net/2022/11/30/wzMOfhPG8V5Xetq.png" style="zoom: 50%;" /><h3 id="32-ir格式转换"><a class="markdownIt-Anchor" href="#32-ir格式转换"></a> 3.2 IR格式转换</h3><p><img src="https://s2.loli.net/2022/11/30/HLeRD2a7Un95vlC.png" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> llvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL的安装与测试</title>
      <link href="/2022/11/11/21-44-45/"/>
      <url>/2022/11/11/21-44-45/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1afl的安装"><a class="markdownIt-Anchor" href="#1afl的安装"></a> 1.AFL的安装</h3><p>先安装gcc，我的虚拟机还没装。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//先安装gcc </span><br><span class="line">sudo apt-get install gcc</span><br><span class="line">//查看gcc版本看是否安装成功</span><br><span class="line">gcc -v</span><br></pre></td></tr></table></figure><p>之后发现还需要clang和llvm，要啥装啥吧。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install clang</span><br><span class="line">sudo apt-get install llvm</span><br></pre></td></tr></table></figure><p>下载AFL，开始愉快地安装，很快啊。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/google/AFL</span><br><span class="line">cd AFL</span><br><span class="line">make</span><br><span class="line">//如果显示make command not found 运行下面两条命令</span><br><span class="line">apt install make</span><br><span class="line">apt upgrade</span><br></pre></td></tr></table></figure><h3 id="2afl测试"><a class="markdownIt-Anchor" href="#2afl测试"></a> 2.AFL测试</h3><p>我根据网上的教程，直接输入<code>afl -fuzz</code> 显示找不到afl命令，那就直接测试一个具体的文件试试。</p><p>创建一个testfile文件夹，然后在该文件夹下创建测试文件afl_test.c，内容如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vuln</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>敲命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">afl-gcc -g -o afl_test test.c</span><br></pre></td></tr></table></figure><p>显示如下</p><p><img src="https://s2.loli.net/2022/11/11/GVoN5SELYvACfTd.png" alt="image-20221013210725121" /></p><p>于是我又试了命令<code>apt install afl</code></p><p>重新尝试，</p><p><img src="https://s2.loli.net/2022/11/11/ykFLXg2E7SjZM9b.png" alt="image-20221013211737042" /></p><p>接着建立fuzz_in文件夹，创建输入文件testcase，输入文件中写几个简单单词，fuzzing时会产生简单变异。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir fuzz_in</span><br><span class="line">echo &quot;hello&quot; &gt; fuzz_in/testcase</span><br></pre></td></tr></table></figure><p>进行fuzz，结果如图。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i fuzz_in -o output ./afl_test</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/11/4hflSNvwZgWYAFs.png" alt="image-20221013212507389" /></p><h3 id="3基于编译器的目标程序插桩"><a class="markdownIt-Anchor" href="#3基于编译器的目标程序插桩"></a> 3.基于编译器的目标程序插桩</h3><h4 id="31下载目标程序集coreutils-91targz"><a class="markdownIt-Anchor" href="#31下载目标程序集coreutils-91targz"></a> 3.1下载目标程序集(coreutils-9.1.tar.gz)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://ftp.gnu.org/gnu/coreutils/coreutils-9.1.tar.gz</span><br><span class="line">tar -zxvf coreutils-9.1.tar.gz</span><br></pre></td></tr></table></figure><h4 id="32使用afl-gcc生成coreutils的每个二进制程序"><a class="markdownIt-Anchor" href="#32使用afl-gcc生成coreutils的每个二进制程序"></a> 3.2使用afl-gcc，生成coreutils的每个二进制程序</h4><ul><li><p>查看 coreutils 的 configure 选项，指定 <code>cc=afl-gcc</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure CC=afl-gcc</span><br></pre></td></tr></table></figure><p>这一步用来生成Makefile，为了下一步编译做准备，可以通过在configure后面加参数进行控制。</p><p>可以通过 <code>./configure --help</code>查看帮助</p><p><strong>问题</strong></p><p><img src="https://s2.loli.net/2022/11/11/qgW81k6nl3UQ9vL.png" alt="image-20221014112413555" /></p><p>通过百度找到<a href="https://blog.csdn.net/tx422/article/details/78593860?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-78593860-blog-115320610.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-78593860-blog-115320610.pc_relevant_aa&amp;utm_relevant_index=2">解决方案</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export FORCE_UNSAFE_CONFIGURE=1</span><br></pre></td></tr></table></figure><ul><li></li></ul></li><li><p>生成 coreutils 二进制程序集。make 出来的每一个插桩后二进制均在 coreutils-9.1/src 目录下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li></ul><h4 id="33为-coreutils-的特定程序确定输入种子"><a class="markdownIt-Anchor" href="#33为-coreutils-的特定程序确定输入种子"></a> 3.3为 coreutils 的特定程序确定输入种子</h4><p>coreutils 包含很多二进制程序，任选其中程序进行 fuzzing。</p><p>构造输入种子列表，存放于coreutils-9.1/src/input 目录下，构造方法可以选择：</p><ul><li><p>学习 coreutils <a href="https://www.gnu.org/software/coreutils/manual/coreutils.html">文档</a>中这 3 个程序的命令行选项，用这些命令行选项构建</p></li><li><p>直接用随机构造的任意字符串作为输入种子。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir input</span><br><span class="line">mkdir output</span><br><span class="line">cp ../../AFL/dictionaries/* ./input # 将字典拷贝到input目录下</span><br></pre></td></tr></table></figure></li></ul><h4 id="34在coreutils-91src-目录下使用-afl-fuzz-i-input-o-output-程序名-进行fuzzing一段时间后终止fuzzing-并在-coreutils-91srcoutput-目录下查看测试结果"><a class="markdownIt-Anchor" href="#34在coreutils-91src-目录下使用-afl-fuzz-i-input-o-output-程序名-进行fuzzing一段时间后终止fuzzing-并在-coreutils-91srcoutput-目录下查看测试结果"></a> 3.4在coreutils-9.1/src 目录下，使用 <code>afl-fuzz -i input -o output ./[程序名] @@</code>进行fuzzing，一段时间后终止fuzzing 并在 <code>coreutils-9.1/src/output</code> 目录下查看测试结果。</h4><p><img src="https://s2.loli.net/2022/11/11/n8hKbgBkUoQXiN4.png" alt="image-20221014113912837" /></p>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献|eTPL</title>
      <link href="/2022/10/27/22-01-46/"/>
      <url>/2022/10/27/22-01-46/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1摘要"><a class="markdownIt-Anchor" href="#1摘要"></a> 1.摘要</h3><p>为了弥补TPL（TLS Presentation Language），文章提出了增强的TPL语言（eTPL）。文章首先定义了一个二进制数据解析的生成模型。基于此，文章为TPL提供了一组可以捕获重要信息的语言结构。如果没有这些结构，TPL中的重要信息只能由人工“手动”获取。最后，文章提出两种软件工具：gmt-c++和etpl-tool。</p><h3 id="2创新点"><a class="markdownIt-Anchor" href="#2创新点"></a> 2.创新点</h3><h4 id="21通用解析模型"><a class="markdownIt-Anchor" href="#21通用解析模型"></a> 2.1通用解析模型</h4><p>受TLS固有的解析范式启发，开发此通用模型来解析TLS的复杂的二进制编码。</p><blockquote><p>解析范式见tls不同版本的规范文档。例如<a href="https://datatracker.ietf.org/doc/html/rfc5246">RFC5246</a></p></blockquote><h5 id="211专用名词与概念解释"><a class="markdownIt-Anchor" href="#211专用名词与概念解释"></a> 2.1.1专用名词与概念解释</h5><ul><li><strong>解析（parsing）</strong>：指二进制数据流转换成一种结构（树）表示的过程，在输入流解析时不能有任何跳变。</li><li><strong>序列化（serialization）</strong>：相反的过程，从树表示转换为二进制流，通过深度优先的树遍历。</li><li><strong>类型（type）</strong>：类型是解析数据的方法。类型可以是“原子的”，没有解析相关的子结构（例如整型或者不透明的原始数据an opaque blob of raw data）；类型也可以是复合的（类似结构体，例如由不同字段组成的网络数据包）。</li><li><strong>字段（filed）</strong>：<em>类型</em>的实例，通常由复合的<em>类型</em>定义。</li><li><strong>解析器（parser/dissector）</strong>:<em>类型</em>解析方法的实现。复合<em>类型</em>的解析器将输入数据流交给子解析器。如果字段依赖于前面字段的解析结果，则相应的子解析器将被实时实例化。要解析的输入流可以以任意碎片的形式提供，即流中的中间不连续性不影响解析结果。</li><li><strong>长度（length）</strong>：<em>解析器</em>在某个时间点上消耗的数据量。</li><li><strong>大小（size）</strong>：<em>解析器</em>或者<em>类型</em>的目标值（可选）。</li><li><strong>溢出（overflow situation）</strong>：所有解析器的子解析器已经满了，但是还有数据流要输入。</li><li><strong>underflow situation</strong>：父解析器已满，但是不是所有的子解析器都满了。</li></ul><p><img src="https://s2.loli.net/2022/11/11/w2dUAN9ljeKE71L.png" alt="image-20221028112948242" /></p><p><img src="https://s2.loli.net/2022/11/11/XhQ7g3pMJLWO4v8.png" alt="image-20221028114126692" /></p><h5 id="212通用消息树generic-message-trees"><a class="markdownIt-Anchor" href="#212通用消息树generic-message-trees"></a> 2.1.2通用消息树（Generic Message Trees）</h5><p>GMT是由<em>解析器</em>实现的消息的树形表示。</p><p>叶子节点与不能再解析的“元消息”有关。</p><p>除了静态和不可变的<em>类型</em>，GMT还拥有动态<em>类型</em>组件，可以由GMT在运行时解析的具体数据来确定。（select/case）</p><p>此外，GMT节点还有可扩展的元信息。</p><p><img src="https://s2.loli.net/2022/11/11/NGb81umdtU5OTsP.png" alt="" /></p><h5 id="213-tpl-etpl"><a class="markdownIt-Anchor" href="#213-tpl-etpl"></a> 2.1.3 TPL &amp; eTPL</h5><p>TPL的定义不明确，可读性差。于是提出了加强型TPL（etpl），部分增强功能如下：</p><ul><li><em><em><em>类型</em>和</em>字段</em>的显示大小（Explicit size of types and fields）**：定义类型与字段的大小。</li><li><strong><em>类型</em>参数化（Type parametrization）</strong>：允许类型具有参数，并定义一个语言构造来在实例化类型时设置这些参数。整数类型的可接受数值限制（最小值/最大值）。</li><li><strong>动态解析上下文（Dynamic parsing context）</strong>：引入了允许使用GMT提供的动态解析上下文的语言结构。解析上下文由嵌入了一个解析器的（部分增长的）GMT给出。具体元素（即GMT节点或与GMT节点相关联的元信息）使用相对于解析器在GMT中的位置的路径来引用。</li></ul><p><img src="https://s2.loli.net/2022/11/11/LA8pZdobVCaSUHX.png" alt="" /></p><h3 id="3复现"><a class="markdownIt-Anchor" href="#3复现"></a> 3.复现</h3><h4 id="31-gmt-cpp"><a class="markdownIt-Anchor" href="#31-gmt-cpp"></a> 3.1 <a href="https://github.com/phantax/gmt-cpp">gmt-cpp</a></h4><p>通用消息树（GMT）的c++实现。</p><ol><li><p>下载库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/phantax/gmt-cpp.git</span><br></pre></td></tr></table></figure></li><li><p>下载 bitbuffers-cpp 库并创建软链接至gmt-cpp的目录。这里建议用绝对路径，否则会出现“链接层数过多”的问题。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/phantax/bitbuffers-cpp.git</span><br><span class="line">ln -s home/mkh/bitbuffers-cpp home/mkh/gmt-cpp/bitbuffers-cpp</span><br></pre></td></tr></table></figure></li><li><p>下载propertynode-cpp 库并创建软链接；与2同理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/phantax/propertynode-cpp.git</span><br><span class="line">ln -s home/mkh/propertynode-cpp home/mkh/gmt-cpp/propertynode-cpp</span><br></pre></td></tr></table></figure></li><li><p>build</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd gmt-cpp</span><br><span class="line">make deps</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li></ol><p>gmt-cpp是一个在C++中实现gmt概念的库。为了使用这些代码，需要一个针对gmt-cpp链接的应用程序。<br />test/子目录中有一个测试应用程序，可以将其用作起点。为了构建和运行测试应用程序（在构建gmt-cpp库之后），键入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make test</span><br><span class="line">./test/test</span><br></pre></td></tr></table></figure><p><strong>test.cpp源代码如下</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InternalNode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tls-with1.3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hex representation of a TLS ClientHello message generated with OpenSSL.</span></span><br><span class="line">    string hex = <span class="string">&quot;0x&quot;</span></span><br><span class="line">            <span class="string">&quot;160301012c01000128030340c70e243001b96d8c63687738696432d3e6f949&quot;</span></span><br><span class="line"><span class="string">&quot;107aabad8450cdffd6a266e4000092c030c02cc028c024c014c00a00a3009f&quot;</span></span><br><span class="line"><span class="string">&quot;006b006a0039003800880087c032c02ec02ac026c00fc005009d003d003500&quot;</span></span><br><span class="line"><span class="string">&quot;84c02fc02bc027c023c013c00900a2009e0067004000330032009a00990045&quot;</span></span><br><span class="line"><span class="string">&quot;0044c031c02dc029c025c00ec004009c003c002f00960041c011c007c00cc0&quot;</span></span><br><span class="line"><span class="string">&quot;0200050004c012c00800160013c00dc003000a001500120009001400110008&quot;</span></span><br><span class="line"><span class="string">&quot;0006000300ff0100006d000b000403000102000a00340032000e000d001900&quot;</span></span><br><span class="line"><span class="string">&quot;0b000c00180009000a00160017000800060007001400150004000500120013&quot;</span></span><br><span class="line"><span class="string">&quot;000100020003000f0010001100230000000d0020001e060106020603050105&quot;</span></span><br><span class="line"><span class="string">&quot;020503040104020403030103020303020102020203000f000101&quot;</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">VectorBuffer buf;</span><br><span class="line"></span><br><span class="line">    buf.<span class="built_in">appendFromString</span>(hex);</span><br><span class="line">    </span><br><span class="line">    TVector_MainType node;</span><br><span class="line"></span><br><span class="line">    node.<span class="built_in">dissector</span>().<span class="built_in">dissectFromBuffer</span>(buf);</span><br><span class="line"></span><br><span class="line">    node.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    DataUnit* testnode = node.<span class="built_in">getByPath</span>(<span class="string">&quot;**/ClientHello_extensions%/_V/~2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~-2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~-2&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~-1&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~0&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~1&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~2&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~r-2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~r-2&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~r-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~r-1&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~r0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~r0&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~r1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~r1&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~r2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~r2&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://s2.loli.net/2022/10/31/CnNcvodT9kLyx8D.png" alt="image-20221027155629256" /></p><h4 id="32-etpl-tool"><a class="markdownIt-Anchor" href="#32-etpl-tool"></a> 3.2 etpl-tool</h4><p>用etpl作为派生解析例程的描述语言。</p><p>we brieflfly presented a software tool that automatically generates C++ message parsers from eTPL defifinitions.</p><p><img src="https://s2.loli.net/2022/10/31/J9AtB4znbdcClN5.png" alt="image-20221031145119569" /></p>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> 文献 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献|tls-differ-testing</title>
      <link href="/2022/10/27/21-56-24/"/>
      <url>/2022/10/27/21-56-24/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>文章：Exploiting Dissent: Towards Fuzzing-Based Differential Black-Box Testing of TLS Implementations</p><p>期刊：  IEEE Transactions on Dependable and Secure Computing；影响因子/JCR分区：6.791/Q1</p><p>作者：Andreas Walz and Axel Sikora</p><p>2022年10月27日</p><p>mkh</p></blockquote><h3 id="1摘要"><a class="markdownIt-Anchor" href="#1摘要"></a> 1.摘要</h3><p>设计和实现一个新的测试方法，旨在帮助开发人员和用户识别黑箱TLS实现中的问题。这是一种将模糊技术和差异测试应用于TLS中身份验证所基于的<code>X.509</code>证书验证例程的方法。</p><p>简单地说，我们使用半随机生成的TLS协议消息来刺激使用等效输入的多个TLS实现，并在它们的响应中使用差异来检测实现bug。</p><p>我们的方法既不需要代码检测也不需要执行监控，这是嵌入式平台开发人员特别感兴趣的特性。</p><p><strong>方法的核心是一种新的模糊算法，它生成TLS协议消息，在不同TLS实现之间触发不同的协议行为时非常有效。</strong></p><p><strong>本文提出了以下贡献:</strong></p><ul><li><p><strong>通用消息树(<em>Generic Message Trees</em>):</strong> 设计并实现了通用消息树<em>Generic Message Trees</em>(GMTs)的概念，这是一种通用的、动态的数据结构，用于高效地操作高度结构化的协议消息。</p></li><li><p>**基于fuzzing的TLS消息生成(Fuzzing-based TLS message generation)😗*基于GMT的概念，我们提出了一种随机算法来生成高度多样化和大多数有效(mostly-valid)的TLS握手消息。</p></li><li><p><strong>ClientHello解析的差分测试(<em>Differential testing of ClientHello parsing</em>):</strong> 我们使用我们的消息生成算法来不同地测试五种流行的TLS服务器实现: OpenSSL,BoringSSL, WolfSSL, mbedTLS, and MatrixSSL. 在此过程中，我们证明了我们的算法比<code>American Fuzzy Lop [27]</code>,<code>TLS-Attacker [28]</code>, and <code>NEZHA</code>更有效地激发不一致的反应.我们使用测试方法研究了TLS实现中暴露的一些bug。</p><blockquote><p>[27] American fuzzy lop (AFL). (2017). [Online]. Available: http://<br /><a href="http://lcamtuf.coredump.cx/afl">lcamtuf.coredump.cx/afl</a></p><p>[28] J. Somorovsky, “Systematic fuzzing and testing of TLS libraries,”<br />in Proc. ACM SIGSAC Conf. Comput. Commun. Secur., Oct. 2016,<br />pp. 1492–1504.</p></blockquote></li><li><p>**软件框架(<em>Software framework</em>)😗*我们为其他研究人员和开发者提供我们的软件[29]。</p><blockquote><p><strong>[29] tls-diff-testing: Differential Handshake Fuzz-Testing of TLS</strong><br /><strong>Implementations. (2017). [Online]. Available: <a href="https://github.com/hso-esk/tls-diff-testing">https://github.com/hso-esk/tls-diff-testing</a></strong></p></blockquote><p>项目地址: <a href="https://github.com/hso-esk/tls-diff-testing">https://github.com/hso-esk/tls-diff-testing</a></p></li></ul><p>目前，我们的方法仅限于挑战嵌入的 ClientHello 消息的解析例程TLS 服务器实现。</p><p>注意，在TLS握手的初始阶段，加密并不构成挑战;  然而此文正在进行的工作的一个重要目标是克服这些限制，并允许测试整个握手过程，包括客户端透视图</p><h3 id="2创新点"><a class="markdownIt-Anchor" href="#2创新点"></a> 2.创新点</h3><h4 id="21通用消息树gmt"><a class="markdownIt-Anchor" href="#21通用消息树gmt"></a> 2.1通用消息树GMT</h4><p>见**[文献]etpl**</p><h5 id="212-分解和序列化"><a class="markdownIt-Anchor" href="#212-分解和序列化"></a> 2.1.2 分解和序列化</h5><p>分解是指将某一消息的原始数据表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>∈</mo><mi mathvariant="script">S</mi></mrow><annotation encoding="application/x-tex">s \in \mathcal{S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.075em;">S</span></span></span></span></span>转换为GMT表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>∈</mo><mi mathvariant="script">T</mi></mrow><annotation encoding="application/x-tex">t \in \mathcal{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.25417em;">T</span></span></span></span></span>的过程。</p><p>分解可以表示为一个函数: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">D</mi><mo>:</mo><mi mathvariant="script">S</mi><mo>→</mo><mi mathvariant="script">T</mi></mrow><annotation encoding="application/x-tex">\mathbf{D}: \mathcal{S} \rightarrow \mathcal{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">D</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.075em;">S</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.25417em;">T</span></span></span></span></span></p><p>反向操作称为序列化，通过遍历GMT深度优先并连接每个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><msub><mi mathvariant="script">V</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">v \in \mathcal{V}_{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">V</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>叶节点的原始数据表示来实现。</p><p>序列化可以表示为一个函数:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">S</mi><mo>:</mo><mi mathvariant="script">T</mi><mo>→</mo><mi mathvariant="script">S</mi></mrow><annotation encoding="application/x-tex">\mathbf{S}: \mathcal{T} \rightarrow \mathcal{S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">S</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.25417em;">T</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.075em;">S</span></span></span></span></span></p><p>大多数特定于格式的方面基本上都是由分解功能 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">D</mi></mrow><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">D</span></span></span></span></span>抽象出来的。因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">D</mi></mrow><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">D</span></span></span></span></span>高度依赖于要分析的消息的格式定义。这与序列化函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">S</mi></mrow><annotation encoding="application/x-tex">\mathbf{S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">S</span></span></span></span></span>相反，后者是完全泛型的。</p><h5 id="213-推导分解功能"><a class="markdownIt-Anchor" href="#213-推导分解功能"></a> 2.1.3 推导分解功能</h5><p>我们的实现方法基于<em>TLS Presentation Languag</em>表示语言(TPL)。TPL在整个TLS规范中用于定义TLS协议消息[1]的内容和编码的目的基本一致。</p><blockquote><p>[1]  T. Dierks and E. Rescorla, “The transport layer security (TLS) protocol version 1.2,” RFC 5246, Aug. 2008, <a href="https://www.rfc-editor.org/rfc/rfc5246.txt">https://www.rfc-editor.org/rfc/rfc5246.txt</a></p></blockquote><p>TPL包括基本消息字段(即整数和枚举字段)以及字段的列表(也称为向量)、构造(复合)类型和变体(即构造类型中的动态选择)。TPL中的消息定义使用的语法非常接近于“C”编程语言。</p><p>TPL本身是自动派生 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">D</mi></mrow><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">D</span></span></span></span></span></p><p>TPL 将自己展示用于自动派生 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">D</mi></mrow><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">D</span></span></span></span></span> 实现的一个有趣的候选者。然而，由于 TPL 受到了一些影响，随意和非正式的定义，出于我们的目的，我们使用 eTPL，TPL 的增强版本 [43]</p><blockquote><p>[43] A. Walz and A. Sikora, “eTPL: An enhanced version of the TLS presentation language suitable for automated parser generation,” in Proc. 9th IEEE Int. Conf. Intell. Data Acquisition Adv. Comput.<br />Syst.: Technol. Appl., 2017, pp. 810–814.</p></blockquote><p>具有改进的表达能力，适合于自动生成解析器，例如，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">D</mi></mrow><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">D</span></span></span></span></span>的实现，以及其他特定于格式的例程。</p><p>因此，可以最小化手动实现特定于tls的细节的任务,从本质上讲，它归结为从TLS规范中复制基于TPL的消息定义，并使用eTPL构造来补充TPL未能涵盖的消息格式的那些特性的定义。</p><h5 id="214-gmt-operators操作"><a class="markdownIt-Anchor" href="#214-gmt-operators操作"></a> 2.1.4 GMT Operators操作</h5><p>给定GMTs的一般性质，我们将GMT操作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span>定义为作用于GMT <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>的抽象操作代理。操作符<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span>在某个确定的GMT 节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><msub><mi mathvariant="script">V</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">v \in \mathcal{V}_{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">V</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 上被调用,但可能影响GMT上任意节点. 例如，调用操作符的节点可能仅仅作为复杂操作遍历整个GMT的起点。</p><p>并不是每个操作符都以一种有意义的方式适用于每个节点。因此，每个运算符<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span>都带有一个过滤器 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>functtion</mtext><msub><mi>F</mi><mi>O</mi></msub><mo>:</mo><mi>v</mi><mo>↦</mo><mi>f</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\text{functtion} F_{O}: v \mapsto f \in\{0,1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord text"><span class="mord">functtion</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span>, 如果可以在节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>上调用操作符<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span>，则返回1，否则返回0.</p><p>观察一下，在一个GMT或其节点上的某些操作会以这样一种方式改变GMT，即重新解剖它(即解剖树的序列化)会产生一个结构上不同的GMT，例如: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">D</mi><mo stretchy="false">(</mo><mi mathvariant="bold">S</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo mathvariant="normal">≠</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">\mathbf{D}(\mathbf{S}(t)) \neq t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">D</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">S</span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>, 这种GMT的重新划分不稳定性主要是由于消息字段之间的依赖性的违反(例如，超出范围的长度)造成的。</p><h4 id="22-输入生成"><a class="markdownIt-Anchor" href="#22-输入生成"></a> 2.2 输入生成</h4><p>我们的模糊算法是基于模板TLS消息的操作,为此，它使用了gmt的概念和前面第4节中介绍的相应操作操作符。与我们所知道的其他黑盒模糊方法相比，我们的方法允许以最小的实现努力覆盖大部分有效TLS消息的空间，但效率非常高。</p><h5 id="221-主要操作符"><a class="markdownIt-Anchor" href="#221-主要操作符"></a> 2.2.1 主要操作符</h5><p>我们定义了下列一组确定性操作。在适用的情况下，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">v^{\prime}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>指节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>后的运算符应用.</p><ul><li>Voiding operator <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mtext>void </mtext></msub></mrow><annotation encoding="application/x-tex">O_{\text {void }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">void </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>:  将子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>v</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span> 替换为一个空叶节点,该操作有效地删除了所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>v</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span> 对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>M</mi><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>s</mi></mrow><annotation encoding="application/x-tex">GMT&#x27;s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">s</span></span></span></span>序列化的贡献，但是保留一个叶节点作为占位符，对后续操作可能很重要。</li><li>Removing operator <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mtext>rem </mtext></msub></mrow><annotation encoding="application/x-tex">O_{\text {rem }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">rem </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: 完全删除子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>v</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span> ,该运算符对节点v序列化的影响与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mtext>void </mtext></msub></mrow><annotation encoding="application/x-tex">O_{\text {void }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">void </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>类似。</li><li>Duplicating operator <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mtext>dupl </mtext></msub></mrow><annotation encoding="application/x-tex">O_{\text {dupl }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">dupl </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>: 复制子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>v</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span> 并将其作为兄弟结点插入，也就是作为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">v^{\prime} \mathrm{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathrm">s</span></span></span></span></span>父结点的子结点插入到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 的右边.</li></ul><p>此外，我们定义了几种模糊操作。</p><ul><li><p>Truncating fuzz operator  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>O</mi><mtext>trund </mtext><mtext>fuzz </mtext></msubsup></mrow><annotation encoding="application/x-tex">O_{\text {trund }}^{\text {fuzz }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.132216em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">trund </span></span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">fuzz </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span></span></span></span>: 删除并截断子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>v</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span> 的节点，使其在运算符应用程序后的序列化被截断为长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，即: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">∣</mo><mi mathvariant="bold">S</mi><mrow><mo fence="true">(</mo><msup><mover accent="true"><mi>v</mi><mo>^</mo></mover><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo fence="true">)</mo></mrow><mo fence="true">∣</mo></mrow><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\left|\mathbf{S}\left(\hat{v}^{\prime}\right)\right|=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathbf">S</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>, 截断后的长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是在 0 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="bold">S</mi><mo stretchy="false">(</mo><mover accent="true"><mi>v</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|\mathbf{S}(\hat{v})|-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathbf">S</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 之间.</p></li><li><p>Integer fuzz operator <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>O</mi><mtext>int </mtext><mtext>fuzz </mtext></msubsup></mrow><annotation encoding="application/x-tex">O_{\text {int }}^{\text {fuzz }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.11361em;vertical-align:-0.264502em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.435498em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">int </span></span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">fuzz </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.264502em;"><span></span></span></span></span></span></span></span></span></span>:  将叶节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 所表示的整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 设为新值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">i^{\prime}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>。</p><ul><li>在全范围模式下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">i^{\prime}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>是在 0 - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>w</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{w}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 之间均匀随机选择的, 其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 是整数字段的位宽。</li><li>在近似模式下,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">i^{\prime}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 是在0 - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>⋅</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2 \cdot i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 之间均匀随机选择的。近似模式有助于保持整数接近典型值。对于每一个应用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>O</mi><mtext>int </mtext><mtext>fuzz </mtext></msubsup></mrow><annotation encoding="application/x-tex">O_{\text {int }}^{\text {fuzz }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.11361em;vertical-align:-0.264502em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.435498em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">int </span></span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">fuzz </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.264502em;"><span></span></span></span></span></span></span></span></span></span>,全范围模式或接近模式是随机选择的，概率相等。<strong>此操作符仅适用于表示整数的叶节点。</strong></li></ul></li><li><p>Content fuzz operator <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>O</mi><mtext>cont </mtext><mtext>fuzz </mtext></msubsup></mrow><annotation encoding="application/x-tex">O_{\text {cont }}^{\text {fuzz }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.096108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">cont </span></span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">fuzz </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>:  随机化叶节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>的原始数据表示。</p><ul><li><p>仅更新模式: 长度保持不变</p></li><li><p>resize-and update模式: 长度在0 - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi mathvariant="normal">∣</mi><mi mathvariant="bold">S</mi><mo stretchy="false">(</mo><mover accent="true"><mi>v</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2|\mathbf{S}(\hat{v})|+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">∣</span><span class="mord"><span class="mord mathbf">S</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 之间随机选择.</p><p>对于每一个应用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>O</mi><mtext>cont </mtext><mtext>fuzz </mtext></msubsup></mrow><annotation encoding="application/x-tex">O_{\text {cont }}^{\text {fuzz }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.096108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">cont </span></span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">fuzz </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>,仅更新模式和重置与更新模式之间的选择是随机的，概率相等。对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="bold">S</mi><mo stretchy="false">(</mo><mover accent="true"><mi>v</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">|\mathbf{S}(\hat{v})|=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathbf">S</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ,resize-and-update 模式概率为1; <strong>该操作符只适用于叶节点。</strong></p></li></ul></li><li><p>Appending fuzz operator <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>O</mi><mtext>app </mtext><mtext>fuzz </mtext></msubsup></mrow><annotation encoding="application/x-tex">O_{\text {app }}^{\text {fuzz }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.232216em;vertical-align:-0.383108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">app </span></span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">fuzz </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span></span></span></span>:插入一个具有随机内容的新叶节点作为节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>的子节点。原始数据的长度是在1到4之间均匀随机选择的。<strong>此操作符仅适用于内部节点。</strong></p></li><li><p>Synthesizing fuzz operator <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>O</mi><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">n</mi></mrow><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">z</mi><mi mathvariant="normal">z</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">O_{\mathrm{syn}}^{\mathrm{fuzz}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.232216em;vertical-align:-0.383108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">s</span><span class="mord mathrm mtight" style="margin-right:0.01389em;">y</span><span class="mord mathrm mtight">n</span></span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight" style="margin-right:0.07778em;">f</span><span class="mord mathrm mtight">u</span><span class="mord mathrm mtight">z</span><span class="mord mathrm mtight">z</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span></span></span></span>:用半随机合成的子树替换子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>v</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span>，该子树遵循节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>类型中固有的消息语法。<strong>尽管合成了语法正确的消息,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>O</mi><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">n</mi></mrow><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">z</mi><mi mathvariant="normal">z</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">O_{\mathrm{syn}}^{\mathrm{fuzz}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.232216em;vertical-align:-0.383108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">s</span><span class="mord mathrm mtight" style="margin-right:0.01389em;">y</span><span class="mord mathrm mtight">n</span></span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight" style="margin-right:0.07778em;">f</span><span class="mord mathrm mtight">u</span><span class="mord mathrm mtight">z</span><span class="mord mathrm mtight">z</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span></span></span></span>不知道对应的语义,</strong></p></li></ul><p>注意, 在概念上,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>O</mi><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">n</mi></mrow><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">z</mi><mi mathvariant="normal">z</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">O_{\mathrm{syn}}^{\mathrm{fuzz}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.232216em;vertical-align:-0.383108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">s</span><span class="mord mathrm mtight" style="margin-right:0.01389em;">y</span><span class="mord mathrm mtight">n</span></span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight" style="margin-right:0.07778em;">f</span><span class="mord mathrm mtight">u</span><span class="mord mathrm mtight">z</span><span class="mord mathrm mtight">z</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span></span></span></span>是最强大的操作,基于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>T</mi><mi>P</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">eTPL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">L</span></span></span></span>定义衍生的解剖函数并植入到GMT节点中，它能够合成模板消息中不存在的消息组件。通过这种方式，任何TLS扩展都可以以语法正确的方式合成。</p><h5 id="222-解决不一致修复"><a class="markdownIt-Anchor" href="#222-解决不一致修复"></a> 2.2.2 解决不一致(修复)</h5><p>某些操作操作符的应用可能会破坏GMT的内部一致性。例如，当一个变长消息组件被截断时，相应的长度字段应该被更新</p><p>显然，在有意地生成不一致的消息(试图挑战实现的输入验证例程)和避免消息不一致(试图防止早期拒绝无效消息)之间存在权衡。因此，我们定义了一种半随机基础上解决GMT节点间不一致性的修复算法(图3)。</p><p><img src="https://s2.loli.net/2022/11/11/bAxJrKCP1qWfnUS.png" alt="image-20210627114016193" /></p><blockquote><p>该算法从某个节点v开始，遍历GMT直至其根节点。</p><p>在确定性模式下(randomize = false)，对于通往根路径上的每个节点，使用特定于节点的函数<code>REPAIRLOCAL(v)</code>解决每个节点的直接子节点之间的局部不一致性。</p><p>在随机模式下(randomize = true) 节点以二分之一的概率被随机跳过(RND函数调用)。RND(x)函数表明在在集合中随机选取返回。 <code>PARENTOF(v)</code>返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>的父节点或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊥</mo></mrow><annotation encoding="application/x-tex">\perp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mrel">⊥</span></span></span></span>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>是根节点.节点以p = 1/2的概率被随机跳过，从而在GMT时间内产生偶然的一致性违规。</p></blockquote><h5 id="223-输入生成算法"><a class="markdownIt-Anchor" href="#223-输入生成算法"></a> 2.2.3 输入生成算法</h5><p>我们的 TLS 消息生成算法的核心如图所示,</p><p><img src="https://s2.loli.net/2022/11/11/QPisArBKO2nUwgo.png" alt="image-20210627115852162" /></p><blockquote><p>从模板消息的 GMT 表示开始，</p><p>重复将随机选择的操作符应用于合适的、随机选择的 GMT 节点,</p><p>在每个运算符应用之后(不包括 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>O</mi><mtext>int </mtext><mtext>fuzz </mtext></msubsup></mrow><annotation encoding="application/x-tex">O_{\text {int }}^{\text {fuzz }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.11361em;vertical-align:-0.264502em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.435498em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">int </span></span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">fuzz </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.264502em;"><span></span></span></span></span></span></span></span></span></span> ) <strong>修复算法</strong>在应用了前一个操作符的节点上调用。</p><p>运算符应用程序的数量是隐式随机选择的;每次迭代后，算法以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">p = 1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span></span></span></span>的概率停止。最终的GMT序列是用于刺激的信息。</p><p>为了避免生成相同位的重复项，我们保留以前生成的消息的哈希列表。话虽如此，这个列表是我们的生成算法所拥有的唯一状态。</p></blockquote><p>不幸的是，除非大规模记录互联网流量，否则获取大量TLS模板消息是一个不小的问题。正如我们在第6节中所展示的，即使只提供了一个模板消息，我们的算法也是有效的。</p><h4 id="23-响应分析"><a class="markdownIt-Anchor" href="#23-响应分析"></a> 2.3 响应分析</h4><p>下面，我们将描述同伴组中实施方案在刺激时收到的反应的差异分析</p><h5 id="231-反应减少函数"><a class="markdownIt-Anchor" href="#231-反应减少函数"></a> 2.3.1 反应减少函数</h5><p>通过使用归约函数(reduction function )<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>  来抽象该度量的具体选择,该函数将 TLS 实现的响应（表示为 GMT <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>∈</mo><mi mathvariant="script">T</mi></mrow><annotation encoding="application/x-tex">t \in \mathcal{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.25417em;">T</span></span></span></span></span>）映射到简化的响应集 R,即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>:</mo><mi mathvariant="script">T</mi><mo>→</mo><mi mathvariant="script">R</mi></mrow><annotation encoding="application/x-tex">R: \mathcal{T} \rightarrow \mathcal{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.25417em;">T</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal">R</span></span></span></span></span>, 来自A,B两个响应<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>B</mi></msub><mo>∈</mo><mi mathvariant="script">T</mi></mrow><annotation encoding="application/x-tex">t_{A}, t_{B} \in \mathcal{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.25417em;">T</span></span></span></span></span>,在归约函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>下被认为是一致的,如果满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mrow><mo fence="true">(</mo><msub><mi>t</mi><mi>A</mi></msub><mo fence="true">)</mo></mrow><mo>=</mo><mi>R</mi><mrow><mo fence="true">(</mo><msub><mi>t</mi><mi>B</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">R\left(t_{A}\right)=R\left(t_{B}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi></mrow><annotation encoding="application/x-tex">\mathcal{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span></span></span></span> 表示实现对等体组,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi></mrow><annotation encoding="application/x-tex">\mathcal{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span></span></span></span>表示测试语料库,即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi mathvariant="script">X</mi></mrow><annotation encoding="application/x-tex">x \in \mathcal{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span></span></span></span>; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{i, x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示从实现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">P</mi></mrow><annotation encoding="application/x-tex">i \in \mathcal{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span></span></span></span>, 测试语句<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi mathvariant="script">X</mi></mrow><annotation encoding="application/x-tex">x \in \mathcal{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span></span></span></span>  得到的响应的GMT表示,我们将响应签名定义为在某些<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>以下的实现响应的元组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub><mo stretchy="false">(</mo><mi mathvariant="script">P</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">⟨</mo><mi>R</mi><mrow><mo fence="true">(</mo><msub><mi>t</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>x</mi></mrow></msub><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>R</mi><mrow><mo fence="true">(</mo><msub><mi>t</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">P</mi><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub><mo fence="true">)</mo></mrow><mo fence="true">⟩</mo></mrow></mrow><annotation encoding="application/x-tex">T_{R}(\mathcal{P}, x)=\left\langle R\left(t_{1, x}\right), \ldots, R\left(t_{|\mathcal{P}|, x}\right)\right\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2051999999999998em;vertical-align:-0.3551999999999999em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">⟨</span></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.08222em;">P</span></span><span class="mord mtight">∣</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">⟩</span></span></span></span></span></span></p><p>显然，我们最感兴趣的是单一刺激在同伴群体中引起的不同反应。作为一种指示性度量，我们将单个刺激获得的唯一反应的数量定义为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>R</mi></msub><mo stretchy="false">(</mo><mi mathvariant="script">P</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">∣</mo><mrow><mo fence="true">{</mo><mi>R</mi><mrow><mo fence="true">(</mo><msub><mi>t</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub><mo fence="true">)</mo></mrow><mo>∣</mo><mi>i</mi><mo>∈</mo><mi mathvariant="script">P</mi><mo fence="true">}</mo></mrow><mo fence="true">∣</mo></mrow></mrow><annotation encoding="application/x-tex">N_{R}(\mathcal{P}, x)=\left|\left\{R\left(t_{i, x}\right) \mid i \in \mathcal{P}\right\}\right|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span><span class="mclose delimcenter" style="top:0em;">}</span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span></span></span></span>, 显然<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>N</mi><mi>R</mi></msub><mo stretchy="false">(</mo><mi mathvariant="script">P</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≤</mo><mi mathvariant="normal">∣</mi><mi mathvariant="script">P</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">1 \leq N_{R}(\mathcal{P}, x) \leq|\mathcal{P}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span><span class="mord">∣</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>R</mi></msub><mo stretchy="false">(</mo><mi mathvariant="script">P</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N_{R}(\mathcal{P}, x)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 当且仅<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi></mrow><annotation encoding="application/x-tex">\mathcal{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span></span></span></span> 中的所有实现都与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>  一致</p><h5 id="232-确定根本原因"><a class="markdownIt-Anchor" href="#232-确定根本原因"></a> 2.3.2 确定根本原因</h5><p>一旦检测到响应差异，确定其根本原因就不是一个简单的问题。目前，这仍然是人工测试人员的手工任务。我们在关于未来工作的第8节中概述了一些关于如何应对这一挑战的想法.</p><p>请注意，行为差异可能不仅仅是由于实现错误。在将不同的实现行为归结为bug之前，需要考虑实现的不同特性或配置以及对规范的不同解释。</p>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> 文献 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊测试小总结</title>
      <link href="/2022/10/20/21-52-50/"/>
      <url>/2022/10/20/21-52-50/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>模糊测试基本流程：预处理、输入数据构造、输入选择、评估、结果分析。</p><p>根据模糊测试对程序内部信息分析的程度,现代的模糊测试方法可以划分为３类:黑盒模糊测试、灰盒模糊测试和白盒模糊测试。</p><p>AFL是覆盖率为导向的模糊测试工具，通过插桩的方法,采集输入数据对应的<strong>边覆盖率</strong>,作为模糊测试种子选取的衡量指标．通过使用进化算法以及精心构造的突变策略。</p><p>通过对源码进行重新编译时进行插桩（简称编译时插桩）的方式利用自动产生测试用例来探索二进制程序内部新的执行路径。AFL也支持直接对没有源码的二进制程序进行测试，但需要QEMU的支持。它可以：</p><ul><li>其可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。</li><li>由于需要在相关代码处插桩，因此AFL主要用于对开源软件进行测试。</li><li>配合QEMU等工具，也可对闭源二进制代码进行fuzzing，但执行效率会受到影响。</li></ul><h3 id="1预处理"><a class="markdownIt-Anchor" href="#1预处理"></a> 1.预处理</h3><p>工作:搜集目标相关信息并制定模糊测试的策略, 为监控目标在测试中的运行状态做必要的准备．通常依赖于<strong>插桩、符号执行以及污点分析</strong>这类程序分析技术</p><p>搜集目标相关信息,比如目标的输入数据格式、目标的内部结构,并为监控测试中目标的状态变化做必要的准备．</p><p>该环节面临的挑战是:使用什么程序分析技术,以及模糊测试究竟需要对目标内部信息有多详细的了解。</p><h4 id="11插桩"><a class="markdownIt-Anchor" href="#11插桩"></a> 1.1插桩</h4><p>插桩技术通向目标代码中合适的位置添加预设好的代码。获得程序的静态或动态执行信息，比如程序的抽象语法树，覆盖率以及函数内变量取值等。</p><p><strong>动态插桩</strong></p><p>是指在运行过程中对代码插桩。比如利用QEMU等模拟技术，可以获得程序运行时的信息，缺点是资源开销大。</p><p><strong>静态插桩</strong></p><p>通过gcc编译器在汇编语言上插桩，LLVM在生成中间语言LLVMIR(low level virtual machine intermediate representation)上插桩。优点是节省时间、速度快，缺点是依赖于程序源码。</p><h4 id="12符号执行"><a class="markdownIt-Anchor" href="#12符号执行"></a> 1.2符号执行</h4><p>将程序行为归结为逻辑领域的推理，通过构建一个表示程序执行的逻辑公式，可以同时推断一个程序在不同输入上的行为。该方法可以使模糊测试获得较好的覆盖率，并可以深入到程序深处。</p><p><strong>静态程序执行</strong></p><p>容易陷入路径爆炸中，用得不多。</p><p><strong>动态符号执行</strong></p><p>动态符号执行通过对程序进行实际执行与符号化执行，维护程序的实际执行和符号化状态，<strong>通过将难以求解的约束替换为实际值，缓解了符号执行的问题</strong>，并按照<strong>深度优先</strong>的搜索策略对目标程序进行了探索。（有点抽象）</p><p>存在的问题：</p><ul><li>路径爆炸问题依然存在，解决办法可以通过启发式算法，选择比较重要的路径探索。</li><li>虽然动态符号执行使用实际值替换的方法，解决了一部分静态符号执行无法绕过的约束，但是也丢失了一部分路径，造成探索结果是不完整的。</li><li>所有符号执行技术都受限于约束求解方法的能力。</li></ul><h4 id="13污点分析"><a class="markdownIt-Anchor" href="#13污点分析"></a> 1.3污点分析</h4><p>观察程序中，哪些数据收到了预先准备好的污染源的污染，目的是跟踪污染源和汇聚点之间的信息流。</p><p><strong>静态污点分析</strong></p><p>通过对程序静态分析,获得程序控制流图、抽象语法树等信息, 依据数据流以及依赖关系进行污点分析。</p><p><strong>动态污点分析</strong></p><p>动态污点分析检测的可信度更高,但是检测结果是否全面, 取决于动态污点分析对程序的覆盖情况,而且动态污点分析会消耗更多的资源; 静态污点分析又会和符号执行一样,可能会陷入到路径爆炸中,而简化后的静态污点分析又存在着严重的过度污染问题。</p><h3 id="2输入构造"><a class="markdownIt-Anchor" href="#2输入构造"></a> 2.输入构造</h3><p><strong>种子获取、种子筛选、种子突变</strong></p><p>具体的挑战是如何在尽量满足语法语义检查的情况下，短时间内生成大量的输入，用以对目标做全面而深入的分析。</p><p>首先得到一个数据S，然后S按照一定的策略进行一定次数的变异，获得大量新数据I，最后将I输入到被测试对象中进行测试，其中数据S被称为种子seed，I是测试实际使用的输入数据。</p><h3 id="3评估"><a class="markdownIt-Anchor" href="#3评估"></a> 3.评估</h3><p>现阶段的研究聚焦于模糊测试器在2个指标上的表现：<strong>覆盖率</strong>和<strong>暴露漏洞平均时间</strong>。</p><p><strong>覆盖率</strong></p><p>软件测试中的一个衡量指标,指的是在测试过程中,对象被覆盖到的数目占总数的比例． 通常而言,高覆盖率更可能发现更多的隐藏漏洞,众多研究因此集中在覆盖率提升上。</p><ul><li><p>AFL 使用上下文无关的<strong>边覆盖率</strong>作为评估指标。</p></li><li><p>Angora 使用上下文敏感的分支覆盖率。</p></li><li><p>VUzzer 使用了块覆盖率替代边覆盖率作为覆盖率评估的对象。</p></li></ul><p><strong>暴露漏洞平均时间</strong></p><p>在 与 基 准 模 糊 工 具AFL的对比实验中，AFLGo复现单个漏洞的时间远比AFL少，这证明了该评估指标的有效性。此后Hawakeye同样使用了这一指标来证明其性能。Parmesan 在通过sanitizer来发现潜在漏洞的研究工作中，也是用暴露漏洞平均时间作为评估指 标同Angora等定向灰盒模糊工具进行比较。</p><h3 id="4结果分析"><a class="markdownIt-Anchor" href="#4结果分析"></a> 4.结果分析</h3><p>发生在模糊测试之后，主要目的是对于模糊测试的输出信息进行分析和处理。</p>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker的学习</title>
      <link href="/2022/10/18/21-49-12/"/>
      <url>/2022/10/18/21-49-12/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1概述"><a class="markdownIt-Anchor" href="#1概述"></a> 1.概述</h3><p>docker是什么？按我的理解类似一个轻量的虚拟机，将计算机资源虚拟化，这里的计算机资源，可以暂时理解成计算能力和数据存储。虚拟化的好处在于，打破资源不可分割的障碍，可以更好地配置。我们可以在docker里面打包网站、程序甚至是它们需要的系统环境，独立打包、互不干扰、方便快捷。</p><p><strong>docker启动流程</strong></p><p><img src="https://s2.loli.net/2022/11/12/JM8zYyXE3wBbmSC.png" alt="img" /></p><p><strong>docker命令概览</strong></p><p><img src="F:/%E5%90%84%E7%A7%8D%E8%AF%BE/fuzz/%E7%AC%94%E8%AE%B0%E6%B1%87%E6%8A%A5/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55Sf5L-h5oqA5pyv,size_20,color_FFFFFF,t_70,g_se,x_16%23pic_center.png" alt="img" /></p><h3 id="2启动docker"><a class="markdownIt-Anchor" href="#2启动docker"></a> 2.启动docker</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker   # 启动Docker</span><br><span class="line">systemctl enable docker  # 设置开机自启动</span><br><span class="line">systemctl stop docker    # 关闭docker</span><br><span class="line">systemctl restart docker #重启docker</span><br><span class="line">docker version           # 查看当前版本号，是否启动成功</span><br><span class="line">docker info             </span><br></pre></td></tr></table></figure><p>帮助命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker --help        #帮助命令</span><br><span class="line">docker pull --help#拉去images的帮助命令</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/12/QCE3R2dsTkfUOXD.png" alt="image-20221018153437685" /></p><p><img src="https://s2.loli.net/2022/11/12/buy8jnRVM7iH3E1.png" alt="image-20221018153525892" /></p><p><img src="https://s2.loli.net/2022/11/12/2UtdHErJYP6ZBTm.png" alt="image-20221018153629701" /></p><h3 id="3镜像命令"><a class="markdownIt-Anchor" href="#3镜像命令"></a> 3.镜像命令</h3><h4 id="31查看本地主机镜像"><a class="markdownIt-Anchor" href="#31查看本地主机镜像"></a> 3.1查看本地主机镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line"></span><br><span class="line"># 可选参数</span><br><span class="line">-a/--all 列出所有镜像</span><br><span class="line">-q/--quiet 只显示镜像的id</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/12/5TCax8FbuI6oYLG.png" alt="image-20221018153925224" /></p><p><strong>列表参数解释</strong></p><ol><li>REPOSITORY  镜像的仓库源</li><li>TAG  镜像的标签</li><li>IMAGE ID 镜像的id</li><li>CREATED 镜像的创建时间</li><li>SIZE 镜像的大小</li></ol><h4 id="32搜索镜像"><a class="markdownIt-Anchor" href="#32搜索镜像"></a> 3.2搜索镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search 镜像名</span><br><span class="line"></span><br><span class="line">#可选参数</span><br><span class="line">Search the Docker Hub for images</span><br><span class="line">Options:</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print search using a Go template</span><br><span class="line">      --limit int       Max number of search results (default 25)</span><br><span class="line">      --no-trunc        Don\&#x27;t truncate output</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/12/2PNqrHjX6nVWeIM.png" alt="img" /></p><h4 id="33拉取镜像"><a class="markdownIt-Anchor" href="#33拉取镜像"></a> 3.3拉取镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名[:tag]</span><br></pre></td></tr></table></figure><p><strong>关于tag</strong></p><p>默认拉取tag为latest的镜像，即最新版本，当然也可以指定版本。</p><p>这里，涉及到docker镜像<a href="https://docs.docker.com/storage/storagedriver/">“层”和存储驱动的知识</a>。简而言之，一个镜像由许多层组成，如果两个镜像有“层”重复，则不需要重复拉取，节约空间。但是，如果镜像被不同的tag标记，即使它们完全相同（“层”也完全相同，共用一组“层”），docker还是会显示两个images，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#拉取了java的镜像，tag为latest</span><br><span class="line">$ docker pull java</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/java</span><br><span class="line">5040bd298390: Pull complete </span><br><span class="line">fce5728aad85: Pull complete </span><br><span class="line">76610ec20bf5: Pull complete </span><br><span class="line">60170fec2151: Pull complete </span><br><span class="line">e98f73de8f0d: Pull complete </span><br><span class="line">11f7af24ed9c: Pull complete </span><br><span class="line">49e2d6393f32: Pull complete </span><br><span class="line">bb9cdec9c7f3: Pull complete </span><br><span class="line">Digest: sha256:c1ff613e8ba25833d2e1940da0940c3824f03f802c449f3d1815a66b7f8c0e9d</span><br><span class="line">Status: Downloaded newer image for java:latest</span><br><span class="line"></span><br><span class="line">$ docker pull java:8-jdk</span><br><span class="line">8-jdk: Pulling from library/java</span><br><span class="line">Digest: sha256:c1ff613e8ba25833d2e1940da0940c3824f03f802c449f3d1815a66b7f8c0e9d</span><br><span class="line">Status: Downloaded newer image for java:8-jdk</span><br><span class="line"></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY   TAG     IMAGE ID   CREATED    SIZE</span><br><span class="line">java    8-jdk    d23bdf5b1b1b  20 months ago  643MB</span><br><span class="line">java    latest    d23bdf5b1b1b  20 months ago  643MB</span><br></pre></td></tr></table></figure><p>这里java版本8-jdk就是最新的，拉取8-jdk时不需要再拉取重复“层”，但是依然显示不同的images</p><h4 id="34删除镜像"><a class="markdownIt-Anchor" href="#34删除镜像"></a> 3.4删除镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi -f 镜像名/镜像ID                            #删除一个 </span><br><span class="line">docker rmi -f 镜像名/镜像ID 镜像名/镜像ID 镜像名/镜像ID   #删除多个</span><br><span class="line">docker rmi -f $(docker images -aq)                   #删除全部</span><br><span class="line">docker images rm 镜像名称/镜像ID                       #强制删除镜像</span><br></pre></td></tr></table></figure><h3 id="4容器命令"><a class="markdownIt-Anchor" href="#4容器命令"></a> 4.容器命令</h3><h4 id="41查看容器"><a class="markdownIt-Anchor" href="#41查看容器"></a> 4.1查看容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps     #查看正在运行的容器列表</span><br><span class="line">docker ps -a  #查看所有容器</span><br></pre></td></tr></table></figure><h4 id="42运行停止容器"><a class="markdownIt-Anchor" href="#42运行停止容器"></a> 4.2运行&amp;停止容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line">docker run -itd --name redis002 -p 8888:6379 redis:5.0.5 /bin/bash  #容器端口与服务器端口映射</span><br><span class="line"></span><br><span class="line">#参数说明</span><br><span class="line">--name=&quot;名字&quot;           指定容器名字</span><br><span class="line">-d                     后台方式运行</span><br><span class="line">-it                    使用交互方式运行,进入容器查看内容</span><br><span class="line">-p                     指定容器的端口</span><br><span class="line">( -p ip:主机端口:容器端口  配置主机端口映射到容器端口</span><br><span class="line">  -p 主机端口:容器端口</span><br><span class="line">  -p 容器端口)</span><br><span class="line">-P                     随机指定端口(大写的P)</span><br><span class="line"></span><br><span class="line">-v                     /宿主机目录:/容器目录 挂载宿主机的一个目录。</span><br><span class="line">                       这里把容器想成一个单独的系统，或者说电脑，而你的宿主机目录是一个U盘，挂载                          后，你往宿主机该目录里放文件，那么通过容器里对应目录便可以访问到此文件，不需                        要重新生成容器就可以在“容器外部”添加和修改某些文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop 容器名/容器ID   #停止容器</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span><br><span class="line">runoob@runoob:~$ docker run -it nginx:latest /bin/bash</span><br><span class="line">root@b8573233d675:/# </span><br></pre></td></tr></table></figure><h4 id="43删除容器"><a class="markdownIt-Anchor" href="#43删除容器"></a> 4.3删除容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm -f 容器名/容器ID  #删除一个</span><br><span class="line">docker rm -f 镜像名/镜像ID 镜像名/镜像ID 镜像名/镜像ID  #删除多个---</span><br><span class="line">docker rmi -f $(docker ps -aq)   #删除全部</span><br></pre></td></tr></table></figure><p><strong>docker生命流程图</strong></p><p><img src="https://s2.loli.net/2022/11/12/XHfZlAz163bv4Wn.png" alt="img" /></p><h3 id="5其他命令"><a class="markdownIt-Anchor" href="#5其他命令"></a> 5.其他命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#获取镜像的元信息：</span><br><span class="line">docker inspect 镜像名</span><br><span class="line"></span><br><span class="line">#将容器导出为tar包：</span><br><span class="line">docker export aa93039fd7fa &gt; aa91.tar</span><br><span class="line"></span><br><span class="line">docker export aa9 -o thinkphp6.tar</span><br><span class="line"> </span><br><span class="line">#将tar包导入为镜像：</span><br><span class="line">docker import tp3-where.tar tp3-where:latest</span><br><span class="line"></span><br><span class="line">#使用start.sh方法启动镜像</span><br><span class="line">docker run -d -p 81:80 vul_thinphp6:latest /start.sh</span><br></pre></td></tr></table></figure><h3 id="6命令的比较"><a class="markdownIt-Anchor" href="#6命令的比较"></a> 6.命令的比较</h3><h4 id="docker-run和docker-start"><a class="markdownIt-Anchor" href="#docker-run和docker-start"></a> docker run和docker start</h4><p>docker run相当于执行了两步操作：将镜像放入容器中（docker create），然后将容器启动，使之变成运行时容器（docker start）。</p><p>而docker start的作用是，重新启动已存在的镜像。也就是说，如果使用这个命令，我们必须事先知道这个容器的ID，或者这个容器的名字，我们可以使用docker ps找到这个容器的信息。</p><h4 id="docker-run和docker-exec"><a class="markdownIt-Anchor" href="#docker-run和docker-exec"></a> docker run和docker exec</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器名/容器ID /bin/bash   #进入容器</span><br></pre></td></tr></table></figure><p>“docker run”通常是在新创建的容器中所使用的命令。 它适用适合没有容器运行的情况，您想要创建一个容器，并且要启动它，然后在其上运行一个进程。</p><p>“docker exec”适用于在现有容器中运行命令的情况。如果您已经拥有了一个正在运行的容器，并希望更改该容器或从中获取某些内容，那么使用“docker exec”命令就非常合适了。</p><h4 id="docker-kill和docker-stop"><a class="markdownIt-Anchor" href="#docker-kill和docker-stop"></a> docker kill和docker stop</h4><p>相同点：两者都是停掉容器，并把容器状态指定到stopped。</p><p>不同点：<br />被kill杀死容器，进入stopped状态被重新start后，会开启新的进程号；<br />被stop停掉的容器，再次被重新start后，进程号不变，还是原来的。</p><p>kill命令比较生猛，不管容器死活，直接给系统发送SIGKILL的系统信号强行kill掉进程，就是要用kill -9干掉容器；</p><p>stop比较温柔，先给容器发送一个TERM信号，给容器充足时间(默认10秒)保存数据，让容器自动安全停止运行，超时后再给系统发送SIGKILL的系统信号强行kill掉进程，最后转变为stop状态。</p><p>使用docker stop -t [s, default 10],可调整超时时间（docker stop -t 20 mynginx）</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再也不会长大</title>
      <link href="/2022/03/24/22-33-02/"/>
      <url>/2022/03/24/22-33-02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>八十岁之后，我的外婆再也没过过生日。她总说，生日是个槛，人越老越不想过。</p><p>我二十岁之后，日子如白驹过隙，果真，我对自己的生日也没那么期待了。</p><p>今年立冬的凌晨，西安倏尔大雪，这是在江南从未见过的景象。他们说，一片大雪就是一股思念，那我的思念也冻了厚厚的一层吧。</p><p>很久以前在南方，外婆把日历撕下来，整齐的一叠。日历纸很薄，节假日红色，平时绿色。外婆的一天就是一张纸，日日分明。</p><p>年关将近，日历变红的时候，我就能见到外公外婆。那时我七八岁，记忆里总是在月明星稀的夜里走回家。月光下，野荡漆黑的水面泛起点点银光，芦苇婆娑。低头赶路，土路深深浅浅，远处家里一盏昏黄的灯渐渐清晰。屋外无限得冷，可心里却温暖——就要到家啦，那是独属于我的温暖。</p><p>进了院门，外公外婆就会迎出来，拴在门房的黑狗也要扑上来舔我的脸。我们一家在院子里用力地跺脚，抖掉一路的风尘，把那一年所有的辛苦和委屈也都留在门外。家里跛脚的老猫被惊醒，抬头“咪呜”一身，又蜷身睡去。</p><p>夜深了，关灯，我盖上厚厚的棉被，半梦半醒地听我妈和外婆说话。村上的生老病死、悲欢离合，说不清也说不完。隐隐听见远处的火车驶过。我躺在床上，像躺在一条古老的船上。</p><p>外公外婆的家永远不关门。他们的儿女，儿女的儿女，匆匆出现又消失，每年来这聚一下，然后再开枝散叶。我们渐渐长大，外公外婆也老了。</p><p>五年前，外公生了重病，吃不下饭，毫无办法。外婆孤单又无助。妈妈打电话给外婆，让她打米糊、熬中药甚至找偏方，外婆一一照办。外公的起居都靠她一人照料。可是外公还是一日日地病下去。终于有一天，妈妈又打电话嘱咐她，外婆忽然落泪：“我十六岁就嫁到这个家，年轻时照顾你爸的妈，老了又照顾你爸，一辈子……我去给你爸热粥了。”妈妈默然。</p><p>我忽然想起童年时的很多事情，想起了我瘦小的外婆。她从来没有这样脆弱，但她也从来没有缺失过对这个家的爱，她有自己的方式。<br />江湖夜雨十年灯。转眼我就二十一岁了，过了二十岁，我一直在想，怎样才能活得有意义、活得不平凡。我在远远的西安想着这些，想起了许多猝不及防的相遇，想起了许多后知后觉的告别，想起了我的亲人，我的童年。</p><p>我渐渐认识到，一辈子只有一次，爱别人胜过爱自己——虽然就一次，也很不容易。</p><p>长大是一件辛苦的事情，但爱不是。我们都在长大，但我们都忘了给自己一个必须去爱的理由。</p><p>外婆家的院子里有棵硕大的柿子树，秋天到了就结满金黄的柿子。有天我在树下捡到一个小柿子，翠绿、坚硬，一股苦寒香，冒着青春期特有的幼稚和傻气。我把它送给外婆，外婆对我说，它再也不会长大啦。</p><p>它再也不会长大。</p><p><img src="https://s2.loli.net/2022/11/12/O4Wy6HmXJkIqzZC.jpg" alt="" /></p><p><img src="https://s2.loli.net/2022/11/12/y8sj7XNTm4IrGdf.png" alt="" /></p><blockquote><p>作于2021年11月9日</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西安碎碎念</title>
      <link href="/2022/03/22/22-15-20/"/>
      <url>/2022/03/22/22-15-20/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-aVGuZwsJ" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="28587882" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>上大学之前我从来没有离开过常州，十九岁第一次出远门，我就去了西安，往返两千四百公里，穿越大半个中国。</p><p>第一次想去西安是看贾平凹的《废都》，浩大的城装满了文人心事。坐在飞机看，西安不再是那个遥远的城市。确实如此，浩浩荡荡，了无际涯。</p><p>西安最不缺的就是历史和文化。散落在城市大大小小的塔，一千五百年；街上枝叶摇落国槐，一千三百年；爬城墙，随便扣块砖，五百年。和女生去看银杏，买五块钱一把的拐枣，小小的，丑丑的，毫不起眼；十一块的杂肝汤，葱蒜漂满碗；还有臭豆腐，黑白相杂，她不吃辣，我就舀了一点辣酱，卧在盒子一角。</p><p>一直想遇到城墙上吹埙的人，就像《废都》里写的一样。埙里有歌：少年时候遇见你，是在哪一天？</p><p>判断对一个城市的熟悉程度，每个人有自己的标准。可能是知道哪家酒馆的酒又好又便宜，可能是知道哪家饭馆的老板娘很美。</p><p>对我来说，是在这座城市遇到可爱的人。华灯初上的时候，一起走大唐不夜城缓缓的坡，夏天还没到，风还很凉快；秋天去香积寺，看满墙的藤蔓慢慢变黄；晚上，小冷，她给我一个硬硬的猕猴桃，在宿舍放了好久，还是硬，砸脑袋还是疼，捂了好久，心里还是冷。</p><p>朝代更迭，沧海桑田。西安不说话，但是教给我很多东西。千百年了，无数遇见和错过之后，西安城陪我走下去。</p><p>可能许多年之后，我在世界上的某个角落某个夜晚，偶尔看到雾霾，见到金黄的叶，吃到硬硬的猕猴桃，恍惚间又到了太白南路，又成了那个瞻前顾后，执拗的少年。</p><p>西安好大；西安好小。“我无处可逃，就像孙悟空飞不出如来的手掌。”</p><p><img src="https://s2.loli.net/2022/11/11/Mz8w42gdi5frmHJ.jpg" alt="" /></p><p><img src="https://s2.loli.net/2022/11/11/AeFHqSL59dDZcNB.png" alt="" /></p><blockquote><p>作于2020年12月13日</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 城市 </tag>
            
            <tag> 西安 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重拾破碎故事之心</title>
      <link href="/2020/11/11/01-31-53/"/>
      <url>/2020/11/11/01-31-53/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>又看了一遍塞林格的《破碎故事之心》，小小的一篇字，很喜欢。</p><p>对里面主人公的告白感触颇深：“有人认为爱是性是婚姻，是清晨六点的吻，是一堆孩子，也许真是这样的，莱斯特小姐。但你知道我怎么想吗，我觉得爱是想触碰，又收回手。”</p><p>如果爱情是一场冒险，坠入爱河永远是最容易的部分。一见钟情的概率比白头偕老大很多。爱情的初心不一样，结局就会不一样。</p><p>人生若只如初见，何事秋风悲画扇。</p><p>爱情永远不是一时的决定，是不断重复的抉择。这也就是为什么有些会浓，有些会淡。</p><p>好的感情的开始，也许是一见如故的感觉。黄昏时的初遇，我可以款款地看着她，说，最近几年我过得不好，我从来没有对别人说过，只是遇见你，不知为何我的眼泪就会落。</p><p>就算知道感情终究归于平淡，我还是相信它，还是觉得“金风玉露一相逢，便胜却人间无数”。</p><p>结局如何，我并不急于知晓。</p><p><img src="https://s2.loli.net/2022/11/12/N6oweukmRxWQTJ3.png" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孩子的事</title>
      <link href="/2020/06/13/01-38-06/"/>
      <url>/2020/06/13/01-38-06/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>接触这群小屁孩半个多月，每日与他们厮混，沾点天真的傻气，好像又回到了七八年前，成了那个醉生梦死的小傻逼。</p><p>童年时代，生活本分的摊在眼前，学习就是学习，玩就是玩，还没有成败和功利，了无牵挂。</p><p>再过三个星期，他们会上不同的中学，从此奔赴不同的人生，相忘于江湖。他们未来要经历的一切，都在现在埋下了伏笔。</p><p>小屁孩们不知道，他们今后接受教育的地方，只是学区房或者积分政策分配的结果，是父母的能力和选择，与自己的成绩无关，可是他们还是会为自己未来的中学争辩，还是会对注定的未来憧憬。</p><p>在这种入学模式下，我也未曾幸免，不过是比别人幸运了一点。</p><p>我想，大多数人都是在出演不是自己选择的剧本，站在不是自己选择的舞台上，这个世界本来就有很多不尽人意。人生的开端不能顺意，至少之后，努力做自己，多点可以奋斗终身的信念，就不会被别人的标准束缚或改变。</p><p>我不是、也不可能成为教师，但我觉得教育的意义，永远不是定义孩子或教孩子用身外之物定义别人，而是让他们学会选择，选择自己生活的方式，并为之承担责任。</p><p>我永远相信，态度比聪明重要，信念比环境重要，孩子早点懂这个道理比一切都重要。</p><p>共勉。</p><p><img src="https://s2.loli.net/2022/11/12/N6oweukmRxWQTJ3.png" alt="小标" /></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教育 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迟到的拳拳离愁</title>
      <link href="/2020/01/30/01-51-00/"/>
      <url>/2020/01/30/01-51-00/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>从老家回来了，洗了个热水澡，钻被窝里，舒坦。</p><p>相比之下，乡下真静。我一个人睡在二楼，听耗子在阁楼上走，歧吱呀呀。恍惚像睡在一条大船上。也只有这样的静，才能消解一天的喧嚣与俗气。</p><p>乡下寂寞，与老辈人没有话说，真要走了，倒有点不舍。外婆招手，车开走，驶了好久回头看，老人家还站在原处。夕阳西下，外婆的暗红棉衣格外显眼。</p><p>二十年了，这与少年时代的无数次离别场景，并没有什么不同。</p><p>小时候离别常哭鼻子，长大了，不知是变得坚强还是麻木，这拳拳离愁，总是迟到。</p><p>这样想想，好像又回到了少年梦多的时候。</p><p>晚安。</p><p><img src="https://s2.loli.net/2022/11/12/N6oweukmRxWQTJ3.png" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
