<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>文献|可追责的医疗属性通行证访问控制方案（AMAP）</title>
      <link href="/2023/11/14/16-33-48/"/>
      <url>/2023/11/14/16-33-48/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>韩刚,王嘉乾,罗维,等. 公共卫生事件中医疗数据访问控制与安全共享研究[J]. 信息安全学报,2023,8(1):40-54. DOI:10.19363/J.cnki.cn10-1380/tn.2023.01.04.</p></blockquote><h2 id="1-问题">1.问题</h2><ul><li>传统医疗系统中，数据信息由不可信第三方进行保管，不可信第三方可能对数据进行任意地伪造、篡改和泄露。</li><li>信息系统没有细粒度的访问控制、权限没有精细划分。</li><li>医疗信息系统访问过程不透明、不可溯源，若发生信息被攻击的情况，无法有效追责。</li></ul><h2 id="2-贡献">2.贡献</h2><ul><li>在基于属性访问控制的基础上，引入<strong>属性访问通行证</strong>，使主体在限定时间内进行访问时，无需再次对属性和访问控制策略进行匹配，保证访问控制完整性严密性的前提下减小开销。</li><li><strong>将访问控制与区块链结合</strong>，解决数据不可篡改、访问公开透明、访问过程不可溯源的问题。</li><li>由于医疗系统的区块链为联盟链，不使用传统的POX系列共识算法，使用<strong>实用拜占庭容错算法</strong>，以实现通过较少节点便可以达成共识的目的。</li></ul><h2 id="3-基础知识">3.基础知识</h2><h3 id="3-1-实用拜占庭容错算法">3.1 实用拜占庭容错算法</h3><p>拜占庭将军问题提出后，有很多的算法被提出用于解决这个问题。这类算法统称为拜占庭容错算法（BTF：Byzantine Fault Tolerance）。它不是一个具体的算法，而是能够抵抗拜占庭将军问题导致的一系列故障的系统属性。这意味着即使某些节点出现缺点或恶意行为，拜占庭容错系统也能继续运转。</p><p><strong>本质来说，拜占庭容错方案就是少数服从多数。</strong></p><p>实用拜占庭容错算法（PBFT）实现了在有限个节点的情况下的拜占庭问题，有3f+1的容错性（拜占庭将军问题也只有在节点数N＞3f时可解），并保证一定的性能。其采用了密码学相关技术（RSA签名、MAC、Hash）确保消息传递过程无法被篡改和破坏。</p><h4 id="3-1-1-3f-1？">3.1.1 3f+1？</h4><p>3f+1指的是总节点数至少为4。先来看看节点数为3，其中有一个叛徒的情况。</p><p>B（接收者）是叛徒：</p><img src="https://s2.loli.net/2023/11/13/Iq813uZdwzK4Llt.png" alt="image-20231113105714909" style="zoom:50%;" /><p>A（发令者）是叛徒：</p><img src="https://s2.loli.net/2023/11/13/yPAt4gZX9vEwklM.png" alt="image-20231113110359062" style="zoom:50%;" /><p>最后的结果中，总有节点为（0,1），即投票1:1，造成不能决断。</p><p>现在来看看4个节点，其中有一个是叛徒的情况。</p><p>C（接收者）是叛徒：</p><img src="https://s2.loli.net/2023/11/13/bdiC4ZR2XQM5Gnh.png" alt="image-20231113110730946" style="zoom:50%;" /><p>A（发令者）是叛徒：</p><img src="https://s2.loli.net/2023/11/13/MjdwkoGTFlgCz1O.png" alt="image-20231113110905412" style="zoom:50%;" /><p>最后，少数服从多数，都会达成一致。</p><p><strong>证明：</strong></p><ul><li>假设有n个节点，其中有f个叛徒，那么忠臣就有n-f个</li><li>必须在n-f个状态复制机（接受的消息）的沟通内，就要做出决定（因为要考虑到叛徒不会发消息的情况）</li><li>但是收到的n-f个消息也不一定都是真的，有可能在做出决定时收到的都是叛徒的消息（叛徒比较勤快），那么n-f个消息中就有f个假的</li><li>那么就有n-f-f个真消息，需要保证n-f-f&gt;f即n&gt;3f</li></ul><p><strong>综上，当恶意节点为f时，只要总节点数≥3f+1，便可以达成共识的达成。</strong></p><h4 id="3-1-2-算法流程">3.1.2 算法流程</h4><img src="https://s2.loli.net/2023/11/13/ls1K4MC2nVIjFfa.png" alt="image-20231113115015113" style="zoom:67%;" /><p><strong>开始阶段</strong></p><ul><li>PBFT算法中节点有两种角色：<strong>主节点（primary）和副本（replica）</strong>，即上述发令者和接收者，两种角色可以互换</li><li>两者的转换引入了<strong>视图（view）<strong>的概念，起到</strong>逻辑时钟</strong>的作用</li><li>确定主节点：p = v mod n计算</li></ul><p><strong>请求</strong></p><ul><li>客户端（c）发送request消息给主节点p（图中的0）</li><li>消息结构：<code>&lt;REQUEST,o,t,c&gt;</code><ul><li><code>o</code>：请求的具体操作</li><li><code>t</code>：追加的时间戳</li><li><code>c</code>：客户端标识</li></ul></li></ul><p><strong>预准备</strong></p><ul><li>主节点收到客户端发送来的消息后，构造<code>pre-prepare</code>消息结构体，广播到集群的其他节点（图中1、2、3）</li><li>消息结构：<code>&lt;&lt;PRE-PREPARE,v,n,d&gt;,m&gt;</code><ul><li><code>v</code>：当前视图编号</li><li><code>n</code>：主节点广播消息的唯一递增序号</li><li><code>d</code>：<code>m</code>的消息摘要</li><li><code>m</code>：客户端发来的消息</li></ul></li></ul><p><strong>准备</strong></p><ul><li>副本收到主节点请求后，会对消息进行检查，检查通过后会将消息存储在本节点，并且变更自身状态到<code>PREPARE</code>状态。状态变更完成后，节点广播消息。</li><li>消息结构：<code>&lt;&lt;PREPARE,v,n,d,i&gt;&gt;</code><ul><li>i：本节点的编号</li></ul></li><li>对消息的有效性检查如下：<ul><li>检查消息体中的摘要<code>d</code>，是否和自己对<code>m</code>生成的摘要一致，确保消息的完整</li><li>检查<code>v</code>是否和当前<code>v</code>一致</li><li>检查序号<code>n</code>是否在水线<code>h</code>和<code>H</code>之间，避免快速消耗可用序号</li><li>检查之前是否接受过相同序号<code>n</code>和<code>v</code>，但是不同摘要<code>d</code>的消息</li></ul></li></ul><p><strong>提交</strong></p><ul><li>副本收到2f+1（包括自己）个一致的<code>PREPARE</code>消息后，会进入<code>COMMIT</code>阶段，并且广播消息给集群中的其他节点</li><li>在收到<code>PREPARE</code>消息后，副本同样也会对消息进行有效性检查，检查内容同准备阶段</li><li>消息结构：<code>&lt;COMMIT,v,n,D(m),i&gt;</code></li></ul><p><strong>回复</strong></p><p>副本收到2f+1（包括自己的）个一致的<code>COMMIT</code>个消息后执行<code>m</code>中包含的操作，其中，如果有多个<code>m</code>则按照序号<code>n</code>从小到大执行，执行完之后发送执行成功的消息给客户端。</p><h2 id="4-系统流程">4.系统流程</h2><h3 id="4-1-通行证申请">4.1 通行证申请</h3><img src="https://s2.loli.net/2023/11/14/Gp3db5J49ufg1Oy.png" alt="image-20231114092504823" style="zoom:67%;" /><ol><li>属性发布方AP将所需所有属性上传至令牌属性管理中心TAMC，TAMC整合所有属性发送到日志部署点LDP，LDP将属性上传至日志链LC，保证所有属性透明公开。</li><li>当主体S申请属性通行证时，S将自己的个人信息上传至TAMC，TAMC对主体信息进行匹配，生成相应的属性通行证token</li><li>S将个人信息上传至密钥分发中心KDC，KDC生成对应的公私钥，将私钥给S，公钥给TAMC</li><li>TAMC生成token后，利用S的公钥对token进行加密并发送给S，同时，TAMC将整个申请过程以及生成通行证的token_id生成日志，并将日志发送到部署点LDP中</li></ol><h3 id="4-2-客体上传">4.2 客体上传</h3><img src="https://s2.loli.net/2023/11/14/uhIMGS6jOzxysU8.png" alt="image-20231114095909959" style="zoom:67%;" /><ol><li>数据拥有者DO首先将所拥有的客体O上传至数据库服务器DB中，DB接收到客体O之后，对O进行hsah，生成客体摘要OH（Object Hash），然后将OH与客体存储地址A发送给数据拥有者DO，DO拿到OH和A后，将数据D上传至数据部署点DDP，DDP将D上传至客体链OC中。</li><li>DO将访问控制策略ACS上传到策略管理点PAP，PAP对策略进行整合并将其发送到策略部署点PLA，策略部署点PLP将ACS部署到OC上</li></ol><h3 id="4-3-访问授权">4.3 访问授权</h3><img src="https://s2.loli.net/2023/11/14/wQeYCmWcUhLOn3b.png" alt="image-20231114101408722" style="zoom:67%;" /><ol><li>S将<strong>通行证</strong>上传至策略执行点PEP，PEP对token进行验证，并记录下token_id</li><li>PEP将token发送给策略决策点PDP，PDP首先判断token_type，然后将token_type上传至策略管理点PAP，PAP根据具体的属性信息匹配ACS，将匹配到的访问控制策略ACS发送给PDP</li><li>PDP将属性信息与对应的访问控制策略ACS发送到访问授权点AAP，AAP根据接收到的属性和访问策略ACS生成的访问凭据access，并将访问凭据access上传至策略执行点PEP。PEP将访问凭据access发送给S和日志部署点LDP。最后由LDP将访问授权日志AAL和访问凭证access部署到日志链LC上。</li></ol><h3 id="4-4-访问">4.4 访问</h3><img src="https://s2.loli.net/2023/11/14/RpstrlUhCxkfb96.png" alt="image-20231114110258987" style="zoom:67%;" /><ol><li>S将access上传到数据服务器DB中，DB对访问凭据access进行验证并判断验证结果，成功则返还对应客体O，反之则拒绝访问请求。</li><li>数据库服务器DB将访问凭据标识符access_id进行记录，并上传日志部署点LDP，LDP继续上链。</li></ol><h2 id="5-实现">5.实现</h2><h3 id="5-1-日志部署点LDP">5.1 日志部署点LDP</h3><p>以<strong>智能合约</strong>的方式在通行证申请阶段、访问授权阶段以及访问阶段发挥作用。</p><ol><li>通行证申请阶段</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> TAMC.<span class="built_in">send</span>( Attribute_all, process) == <span class="literal">true</span> <span class="comment">//当TAMC将属性Attribute_all和主体申请过程process上传至LDP条件达成时</span></span><br><span class="line">    &#123;</span><br><span class="line">LDP.<span class="built_in">get</span>( Attribute_all , process)<span class="comment">//LDP获取</span></span><br><span class="line">u = LDP.<span class="built_in">arrange</span>( Attribute_all , process)<span class="comment">//LDP整合</span></span><br><span class="line">LDP.<span class="built_in">upload</span>(u)<span class="comment">//上传</span></span><br><span class="line">&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol start="2"><li>访问授权阶段</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> PEP.<span class="built_in">send</span>(access) == <span class="literal">true</span><span class="comment">//当PEP将访问凭据access上传到LDP时条件达成</span></span><br><span class="line">&#123;</span><br><span class="line">LDP.<span class="built_in">get</span>(access)<span class="comment">//LDP获取</span></span><br><span class="line">a = LDP.<span class="built_in">arrange</span>(access)<span class="comment">//LDP整合</span></span><br><span class="line">LDP.<span class="built_in">upload</span>(a)<span class="comment">//上传</span></span><br><span class="line">&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol start="3"><li>访问阶段</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> DB.<span class="built_in">send</span>(access_id) == <span class="literal">true</span><span class="comment">//数据库DB将访问凭证的唯一标识符access_id上传到LDP时条件达成</span></span><br><span class="line">&#123;</span><br><span class="line">LDP.<span class="built_in">get</span>(access_id)<span class="comment">//LDP获取</span></span><br><span class="line">LDP.<span class="built_in">upload</span>(access_id)<span class="comment">//上传</span></span><br><span class="line">&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="5-2-数据部署点DDP">5.2 数据部署点DDP</h3><p>DDP以智能合约的方式在客体上传阶段发挥作用。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> DB.<span class="built_in">send</span>(OH,A)==<span class="literal">true</span><span class="comment">//当数据库服务器 DB 向数据部署点 DDP发送客体摘要值OH和客体地址A时，条件达成</span></span><br><span class="line">&#123;</span><br><span class="line">DDP.<span class="built_in">get</span>(OH,A)</span><br><span class="line">DDP.<span class="built_in">upload</span>(OH,A)</span><br><span class="line">&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="5-3-策略部署点PLP">5.3 策略部署点PLP</h3><p>策略部署点PLP以智能合约的方式在客体上传阶段发挥作用。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> PAP.<span class="built_in">send</span>(ACS) == <span class="literal">true</span><span class="comment">//当策略管理点PAP向策略部署点 PLP发送访问控制策略ACS条件达成</span></span><br><span class="line">&#123;</span><br><span class="line">PLP.<span class="built_in">get</span>(ACS)<span class="comment">//获取数据</span></span><br><span class="line">PLP.<span class="built_in">upload</span>(ACS)<span class="comment">//上传</span></span><br><span class="line">&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="5-4-策略执行点PEP">5.4 策略执行点PEP</h3><p>策略执行点PEP以智能合约的方式在访问授权阶段发挥作用，分别在主体S发送上传通行证以及访问授权点AAP将访问凭据access发送给策略执行点PEP的条件达成时，PEP接收访问凭据access并实现对应功能，具体过程如下：</p><ol><li>S发送token时</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> S.<span class="built_in">send</span>(token) ==<span class="literal">true</span><span class="comment">//S发送token时条件达成</span></span><br><span class="line">&#123;</span><br><span class="line">PEP.<span class="built_in">get</span>(S_token)</span><br><span class="line"><span class="keyword">if</span> PEP.<span class="built_in">verify</span>(S_token) == <span class="literal">true</span><span class="comment">//验证</span></span><br><span class="line">&#123;</span><br><span class="line">PEP.<span class="built_in">record</span>(token_id)<span class="comment">//记录token_id</span></span><br><span class="line">PEP.<span class="built_in">send</span>(S_token) to PDP<span class="comment">//发送token_id给PDP  </span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol start="2"><li>AAP 发送访问凭据 access</li></ol><p>当访问授权点AAP发送访问凭据access的条件达成时，PEP 首先得到 access，然后将access发送给主体S以及日志部署点LDP。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 数据安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openTDF quickstart</title>
      <link href="/2023/10/27/13-09-39/"/>
      <url>/2023/10/27/13-09-39/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>注意：以下操作都在root用户下进行，输入命令<code>sudo su</code>，再输入password，强制进入root用户。</p><h2 id="1-准备工具">1.准备工具</h2><h3 id="1-1-安装docker">1.1 安装docker</h3><p>详见<a href="https://www.runoob.com/docker/ubuntu-docker-install.html">菜鸟教程docker安装</a><br>推荐使用官方安装脚本自动安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://test.docker.com -o test-docker.sh</span><br><span class="line">sudo sh test-docker.sh</span><br></pre></td></tr></table></figure><p>测试docker是否安装完成，输入以下指令，出现如下信息即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker run hello-world</span></span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">1b930d010525: Pull complete                                                                 Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5f</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> \1. The Docker client contacted the Docker daemon.</span><br><span class="line"> \2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">  . (amd64)</span><br><span class="line"> \3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">  executable that produces the output you are currently reading.</span><br><span class="line"> \4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">  to your terminal.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta prompt_"> $ </span><span class="language-bash">docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/..</span><br></pre></td></tr></table></figure><p>记得给docker换国内源，设置docker开机自启。</p><h3 id="1-2-安装kubectl">1.2 安装kubectl</h3><p>Kubectl是控制 KSs的基本工具，输入以下命令安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -LO &quot;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl&quot; &amp;&amp; chmod +x kubectl &amp;&amp; sudo mv kubectl /usr/local/bin/kubectl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl -O指获取链接文件，不更改文件名</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">chmod</span> +xm命令为文件增加执行权限</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">mv</span>命令将下载好的文件夹发送到指定目录下，这时系统已经可以检测到kubectl命令</span></span><br></pre></td></tr></table></figure><p>输入<code>kubectl version</code>命令查看是否装好，如下图</p><p><img src="https://s2.loli.net/2023/10/27/9uKIW3FnlzPOwNB.jpg" alt="微信图片_20231027111654.jpg"></p><h3 id="1-3-安装kind">1.3 安装kind</h3><p>kind工具在本机模拟单机k8s环境，输入以下命令安装，注意版本号：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -Lo kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64 &amp;&amp; chmod +x kind &amp;&amp; sudo mv kind /usr/local/bin/kind</span><br></pre></td></tr></table></figure><p>同样，输入<code>kind version</code>命令查看是否装好，如下图</p><p><img src="https://s2.loli.net/2023/10/27/iGUr21mnXYPshfR.jpg" alt="微信图片_20231027111638.jpg"></p><h3 id="1-4-安装helm">1.4 安装helm</h3><p>helm工具可以理解为k8s的包管理工具，类似于python的pip，Ubuntu的apt，输入以下命令安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -LO https://get.helm.sh/helm-v3.8.2-linux-amd64.tar.gz &amp;&amp; tar -zxvf helm-v3.8.2-linux-amd64.tar.gz &amp;&amp; chmod +x linux-amd64/helm &amp;&amp; sudo mv linux-amd64/helm /usr/local/bin/helm</span><br></pre></td></tr></table></figure><p>输入<code>helm version</code>命令查看是否装好，如下图</p><p><img src="https://s2.loli.net/2023/10/27/EHY52zivfekghJm.jpg" alt="微信图片_20231027111645.jpg"></p><h3 id="1-5-安装Tilt">1.5 安装Tilt</h3><p>tilt工具为k8s提供“一键部署”脚本，同时提供一个后台监控页面。输入以下命令安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://github.com/tilt-dev/tilt/releases/download/v0.30.0/tilt.0.30.0.linux.x86_64.tar.gz | tar -xzv tilt &amp;&amp; sudo mv tilt /usr/local/bin/tilt</span><br></pre></td></tr></table></figure><p>由于下载位于github，可能会比较慢，耐心等待，或者本机<s>科学上网</s>后，使用<code>curl -x</code>为curl设置代理。</p><p>输入<code>tilt version</code>命令查看是否装好，如下图</p><p><img src="https://s2.loli.net/2023/10/27/nmEolBXu9NzJgPj.jpg" alt="微信图片_20231027111651.jpg"></p><h2 id="2-拉取opentdf仓库">2.拉取opentdf仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/opentdf/opentdf.git</span><br><span class="line">cd opentdf/quickstart</span><br></pre></td></tr></table></figure><p>如果git下载慢，则考虑本机下载文件夹，不使用<code>git</code>命令，<strong>或者，为git设置代理</strong>。</p><p>一般情况下，本机实现了<s>科学上网</s>，但是git访问github还是很慢，因为git默认不走系统代理，需要手动设置。</p><p>例如，本机开启<s>科学上网</s>，系统代理后，查看网络配置，<code>IP:port</code>为<code>127.0.0.1:7890</code>，如图：</p><img src="https://s2.loli.net/2023/10/27/TRNx739zHjhFkWs.jpg" alt="微信图片_20231027111952.jpg" style="zoom:67%;" /><p>用以下命令临时设置git代理</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy https://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>设置后用以下命令查看是否成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --get http.proxy</span><br><span class="line">git config --global --get https.proxy</span><br></pre></td></tr></table></figure><p>用以下命令取消代理</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="3-登录ghcr-io"><a href="http://3.xn--ghcr-fd3h989i.io">3.登录ghcr.io</a></h2><p>登录<a href="https://github.com/settings/tokens/new">https://github.com/settings/tokens/new</a> 页面勾选 write:packages 和 read:packages ， repo 会自动选中，有效期选无限，创建 Token，并保存。</p><p>把你的TOKEN放到下面，然后登录，成功后显示 Login Succeeded</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Log <span class="keyword">in</span> to GitHub Container Registry</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">export</span> CR_PAT=YOUR_TOKEN</span></span><br><span class="line">export CR_PAT=ghp_unxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">echo $CR_PAT | docker login ghcr.io -u xxxxxx --password-stdin</span><br></pre></td></tr></table></figure><h2 id="4-创建集群">4.创建集群</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kind create cluster --name opentdf</span><br></pre></td></tr></table></figure><p>第一次创建会比较慢，耐心等待。</p><h2 id="5-修改配置脚本">5.修改配置脚本</h2><p>由于网络和版本问题，还需要对Tiltfile等脚本文件进行修改。</p><p>查看Tiltfile文件，修改47行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm_repo(</span><br><span class="line">    &quot;bitnami-archive&quot;,</span><br><span class="line">    &quot;https://raw.githubusercontent.com/bitnami/charts/archive-full-index/bitnami&quot;,</span><br><span class="line">    labels=&quot;utility&quot;,</span><br><span class="line">)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">改为</span></span><br><span class="line"></span><br><span class="line">helm_repo(</span><br><span class="line">    &quot;bitnami-archive&quot;,</span><br><span class="line">    &quot;https://codecentric.github.io/helm-charts&quot;,</span><br><span class="line">    labels=&quot;utility&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>接着，在<a href="https://github.com/kubernetes/ingress-nginx/releases/tag/helm-chart-4.0.16">这里</a>下载ingress-nginx-4.0.16.tgz，解压，<strong>记好该文件夹的路径</strong>，进入其文件夹，修改values.yaml文件19，20行，保存。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">registry:</span> <span class="string">k8s.gcr.io</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">ingress-nginx/controller</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">#改为</span></span><br><span class="line"></span><br><span class="line"><span class="attr">registry:</span> <span class="string">registry.aliyuncs.com/google_containers</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">nginx-ingress-controller</span></span><br></pre></td></tr></table></figure><p>重新修改<code>quickstart</code>目录下的Tiltfile文件，修改63行，将路径改为刚才ingress-nginx文件夹的路径</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm_resource(</span><br><span class="line">    &quot;ingress-nginx&quot;,</span><br><span class="line">    &quot;k8s-in/ingress-nginx&quot;,</span><br><span class="line">    flags=[</span><br><span class="line">        &quot;--version&quot;,</span><br><span class="line">        &quot;4.0.16&quot;,</span><br><span class="line">        &quot;--set&quot;,</span><br><span class="line">        &quot;controller.config.large-client-header-buffers=20 32k&quot;,</span><br><span class="line">        &quot;--set&quot;,</span><br><span class="line">        &quot;controller.admissionWebhooks.enabled=false&quot;,</span><br><span class="line">    ],</span><br><span class="line">    labels=&quot;third-party&quot;,</span><br><span class="line">    port_forwards=(&quot;&#123;&#125;:80&quot;.format(INGRESS_HOST_PORT) if INGRESS_HOST_PORT else None),</span><br><span class="line">    resource_deps=[&quot;k8s-in&quot;],</span><br><span class="line">)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">改为</span></span><br><span class="line"></span><br><span class="line">helm_resource(</span><br><span class="line">    &quot;ingress-nginx&quot;,</span><br><span class="line">    &quot;k8s-in/ingress-nginx&quot;,#从本地加载。改为自己的路径。chart文件</span><br><span class="line">    flags=[</span><br><span class="line">        &quot;--version&quot;,</span><br><span class="line">        &quot;4.0.16&quot;,</span><br><span class="line">        &quot;--set&quot;,</span><br><span class="line">        &quot;controller.config.large-client-header-buffers=20 32k&quot;,</span><br><span class="line">        &quot;--set&quot;,</span><br><span class="line">        &quot;controller.admissionWebhooks.enabled=false&quot;,</span><br><span class="line">    ],</span><br><span class="line">    labels=&quot;third-party&quot;,</span><br><span class="line">    port_forwards=(&quot;&#123;&#125;:80&quot;.format(INGRESS_HOST_PORT) if INGRESS_HOST_PORT else None),</span><br><span class="line">    resource_deps=[&quot;k8s-in&quot;],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="6-启动">6.启动</h2><p>进到 <code>quickstart</code>目录下，运行 <code>tilt up</code>, 然后输入 t， 显示各个组件的状态。</p><p><img src="https://s2.loli.net/2023/10/27/NZ7XuloBxLEiaIU.png" alt="微信图片_20231027120908.png"></p><p>也可以通过http://localhost:10350端口查看各个组件的日志，进行重新启动的操作等等。</p><p><img src="https://s2.loli.net/2023/10/27/i8zJkYb9Uq1GELd.png" alt="微信图片_20231027121037.png"></p><p>第一次运行，需要pull image， 会比较耗时间，有可能失败，不要怕， ctrl +c 结束后， 继续 tilt up，重新运行就好。</p><p>登录abacus， 由于abacus只能用localhost访问，不能用IP访问,需要解决一下。</p><p>链接是如下：</p><p><a href="http://localhost:65432/">http://localhost:65432/</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 数据安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABAC </tag>
            
            <tag> opentdf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSO、CAS、OAuth、OIDC的区别</title>
      <link href="/2023/09/13/09-56-22/"/>
      <url>/2023/09/13/09-56-22/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="认证与授权的区别">认证与授权的区别</h2><ul><li>认证（Authentication，AuthN）即“你是谁”，确认用户身份。</li><li>授权（Authoriztion，AuthZ）即“你可以做啥”，根据用户身份授予他访问特定资源的权限。</li></ul><p>当用户登录系统时，系统需要先<strong>认证</strong>用户身份，再依据用户身份<strong>授权</strong>。认证和授权需要联合使用，才能让用户真正登录并使用应用系统。</p><h2 id="单点登录（Single-Sign-On，SSO）">单点登录（Single Sign-On，SSO）</h2><p>多个站点都要登录，但是每个站点都维护一套登录服务太过麻烦，只需要一套SSO系统，就可以帮助用户快捷访问网络中的多个站点。该协议通过多个系统之间的用户身份信息的交换来实现单点登录。用户只需要记忆一个口令，登陆一次，就可以访问多个系统。</p><p>SSO是一种实现目标，具体怎么做请看下面各个具体的实现。</p><img src="https://s2.loli.net/2023/09/12/i36Yrb4k5nJFmhB.png" alt="image-20230912162058515" style="zoom:67%;" /><h2 id="CAS">CAS</h2><p>Central Authtication Service，CAS。常见的B/S架构SSO协议。</p><p><strong>仅用于AuthN</strong>，CAS认证流程包括几部分参与者：</p><ul><li>Client：通常为使用浏览器的用户</li><li>CAS Client：实现CAS协议的web应用</li><li>CAS Server：统一认证的CAS服务器</li></ul><p>流程如下：</p><img src="https://s2.loli.net/2023/09/12/VysC3nNRaApQkOK.png" alt="image-20230912162218906" style="zoom: 80%;" /><ol><li>用户在浏览器里请求访问web应用example</li><li>浏览器发起一个GET请求访问example的网页 <a href="https://www.example.com">https://www.example.com</a></li><li>应用example发现当前用户处于未登录状态，Redirect用户至CAS服务器进行认证</li><li>请求CAS服务器</li><li>CAS发现用户未登录，要求用户登录</li><li>CAS服务器返回登录页面至浏览器</li><li>用户在登录界面中输入用户名和口令（或其他认证方式）</li><li>用户将用户名和口令通过POST，提交给CAS服务器</li><li>CAS对用户进行认证，若用户名和口令正确，则生成SSO会话，并把会话ID通过cookie的方式返回至用户的浏览器端（此时，用户在CAS服务端处于登陆状态）</li><li>CAS服务器同时也会把用户重定向至CAS Client，并且同时发送一个Server Ticket</li><li>CAS Client收到Server Ticket，请求CAS Server对ticket进行校验</li><li>CAS Server把校验结果返回给CAS Client，校验结果包括ticket是否合法，以及ticket中包含的用户信息</li><li>至此，CAS Client根据Service Ticket得知登录用户身份，CAS Client处于登录态。</li></ol><p>当登录一个Client2时，用户不需要再次认证，跳过5，6，7，8，9这几个步骤。</p><p>用的越来越少，因为它之解决认证部分，不授权。</p><h2 id="OAuth-2-0">OAuth 2.0</h2><p>其实是一种AuthZ协议，不用来认证，关注<strong>授权</strong>本身。但是在实际使用中，授权脱离了认证没有任何意义。</p><p>OAuth 2.0解决的主要场景是：第三方应用如何被授权访问资源服务器。整个流程包括以下几个部分：</p><ul><li>Resource Owner：资源拥有者，通常为终端用户</li><li>Resource Server：资源提供者</li><li>Authorization Sever：授权服务器</li><li>Client：请求访问服务的应用</li></ul><p>大致流程如下:</p><img src="https://s2.loli.net/2023/09/12/SJ9ZgflE8jH1TMN.png" alt="image-20230912171856209" style="zoom:67%;" /><p>假定一个在线音乐服务，用户zhangsan（Resource Owner）想通过某音视频播放软件（client）来播放在线音乐，但是在播放音乐之前，该音视频软件必须得通过YuFu(即玉符IDaaS)（Authorization Server）认证授权，得到zhangsan的同意之后才能访问在线音乐。</p><p>在这个场景中，zhangsan为Resource Owner，在线音乐服务为Resource Server，Client为某音视频播放软件，YuFu作为Authorization Server。</p><ol><li>音视频软件向zhangsan发起授权请求，请求zhangsan同意访问在线音乐服务</li><li>根据不同的授权模式，zhangsan同意该授权，且返回一个&quot;授权&quot;给音视频服务，音视频服务携带zhangsan的授权，请求YuFu颁发一个access_token，用于访问在线音乐</li><li>YuFu校验音视频服务自身的合法性之后，颁发access_token</li><li>音视频服务携带access_token，代表zhangsan请求访问在线音乐</li><li>在线音乐服务校验完access_token以后，提供音乐服务。播放器开始播放音乐。</li></ol><p>上述是一个抽象的授权流程，而在具体实现中，在前三步中会有几个变种，即不同的授权模式，常见的授权模式包括:</p><ul><li>Authorization Code Grant：授权码模式，最为常用，最安全，强烈推荐</li><li>lmplicit Grant：适用于SPA应用，已经不再推荐使用，被PKCE模式所替代</li><li>Resource Owner Password Credentials Grant：需要把用户的用户名和密码暴露给Client</li><li>Client Credential Grant：整个流程没有用户的概念，适用于服务端-&gt;服务端调用的场景。</li></ul><p>可以发现在整个流程中，音视频播放器并不需要知道zhangsan的密码，只是需要得到zhangsan的授权就可以访问在线音乐，而整个授权是由Authorization Server来负责。</p><p>本文并不会展开讨论Authorization Code模式，详细协议文档定义请参考：<a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a></p><p>相比CAS协议，OAuth2.0不同的授权模式能够解决更多的场景，更安全、更流行，且通过PKCE模式能够实现移动端的单点登录，这是其他SSO协议都不具备的。</p><h2 id="OpenID-Connect">OpenID Connect</h2><p>OpenID Connect简称OIDC，是基于OAuth 2.0扩展出的一个协议。除了能实现OAuth2.0的AuthZ，还额外定义了AuthN场景，是当今最流行的协议。</p><p>相比OAuth 2，OICD引入了id_token和userinfo相关的概念：</p><ul><li>OAuth 2.0只是定义了access_token/refresh_token，但是这俩只是为了保护Resource Server的，并没有包含Resource Owner的信息；</li><li>OIDC引入了id_token的概念，用这个特殊的token来表示这是Resource Owner的身份证：<ul><li>标准化id_token的格式：即大家熟知的JWT；</li><li>标准化id_token的内容：standard claims；<ul><li>参考：<a href="https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims">https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims</a></li></ul></li></ul></li><li>OIDC引入了关于如何获取详细userinfo的Endpoint；</li><li>OIDC定义了类似于SAML Metadata的Discovery接口，俗称well-known接口：<ul><li>参考： <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">https://openid.net/specs/openid-connect-discovery-1_0.html</a></li></ul></li></ul><p>OIDC协议的登陆授权流程和OAuth2.0基本类似，整个流程的参与者也类似，只不过换了个术语：</p><ul><li>OpenlD Provider：简称OP，负责认证和授权</li><li>Relying Party：简称RP，OAuth 2.0中的Client</li></ul><img src="https://s2.loli.net/2023/09/12/j6yPOKdhuNkaHU3.png" alt="image-20230912205855338" style="zoom:67%;" /><p>OIDC协议是目前最主流的SSO标准协议，且对开发者友好，实现起来比较简单。</p><h2 id="SAML-2-0">SAML 2.0</h2><p>古老的协议，没人用了。</p><p>Security Assertion Markup Language，基于XML的标准协议。</p><h2 id="简单对比">简单对比</h2><table><thead><tr><th style="text-align:center">比较项</th><th style="text-align:center">CAS</th><th style="text-align:center">OAuth</th><th style="text-align:center">OIDC</th><th style="text-align:center">SAML</th></tr></thead><tbody><tr><td style="text-align:center">支持AuthN</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">支持AuthZ</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">传输方式</td><td style="text-align:center">HTTP</td><td style="text-align:center">HTTP</td><td style="text-align:center">HTTP</td><td style="text-align:center">HTTP</td></tr><tr><td style="text-align:center">票据格式</td><td style="text-align:center">server ticket，proxy ticket<br />协议定义为一个opaque的ticket，没有标准格式</td><td style="text-align:center">acces_token,refresh_token<br />协议定义为一个opaque的ticket，没有标准格式</td><td style="text-align:center">acces_token,refresh_token,id_token<br />access_token,<br/>refresh_token同OAuth2.0，是一个opaque的token，没有标准格式<br/>id_token是一个标准的JWT格式的token，且有标准claim的定义</td><td style="text-align:center">assertion，AuthNRequest等<br />基于XML格式，遵循SAML统一格式定义</td></tr><tr><td style="text-align:center">主要应用场景</td><td style="text-align:center">B/S架构，基于浏览器的SSO</td><td style="text-align:center">B/S架构，基于浏览器的授权</td><td style="text-align:center">B/S架构。基于浏览器的SSO和授权<br />PKCE模式可以用来实现移动端的SSO场景</td><td style="text-align:center">B/S架构，基于浏览器的SSO</td></tr><tr><td style="text-align:center">优势</td><td style="text-align:center">基本没优势</td><td style="text-align:center">协议实现简单，能解决场景多<br />成熟度高，社区支持广泛</td><td style="text-align:center">协议简单易实现，能解决的场景多<br />成熟度高<br />可以同时AuthN和AuthZ</td><td style="text-align:center">最全面的SSP协议之一</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 数据安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABAC </tag>
            
            <tag> opentdf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vlog|黄山之行</title>
      <link href="/2023/08/08/15-43-37/"/>
      <url>/2023/08/08/15-43-37/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div align="center" class="aspect-ratio">  <iframe    src="https://player.bilibili.com/player.html?aid=832688423&&page=1&as_wide=1&high_quality=1&danmaku=0"    scrolling="no"    border="0"    frameborder="no"    framespacing="0"    high_quality="1"    danmaku="1"    allowfullscreen="true"  ></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 城市 </tag>
            
            <tag> 山 </tag>
            
            <tag> 旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于告别</title>
      <link href="/2023/06/25/17-13-30/"/>
      <url>/2023/06/25/17-13-30/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>又是一个离别特别多的夏天。</p><p>午后的炎热把离别拉得很漫长。参加完毕业典礼，我的舍友默默翻出大二的迎新工牌，收好文创小徽章，把与前女友的合照拿起又放下。我看到他眨眨眼，就好像看到他心里点点的涟漪。</p><p>他头也不回地走了，随后我的朋友们也都走了，像退潮一样，像从一个梦里醒过来一样。旋即，我们又将陷入生活的漩涡。</p><p>想到多年前的夏天，我从常州赶往老家赴一场离别，去见外公的最后一面。他消瘦、干扁，等待咽下最后一口气。但是他的手没变，温暖、宽阔，我握住它，就想起七岁外公放在我掌心的蝉，十岁外公接我放学时天边的云彩。告别外公，就像告别童年许许多多个鲜亮的自己。</p><p>离别后我想念一个人，但我不说。我天真地觉得，离别不是永别，蝉鸣依旧，天边的云彩还在，就像曾经许许多多次一样。</p><p>我的外公去世快七年了，这些年我觉得自己已经不会再为他悲伤。直到今天，我带着学士帽在远望谷门前傻傻地笑，等着拍照，我看到远方小小的人群攒动，看到天边大团的云，忽然好想他。</p><p>告别需要仪式，它让情感有了释放的归宿，让离别有了具象的外形。能告别是一种体面，更是一种善意。</p><p>想到我们都要臣服于岁月，我还想再勇敢一点，我不得不再勇敢一点。</p><p><img src="https://s2.loli.net/2023/06/27/RKZE4PbUgCOQ692.png" alt=""></p><p><img src="https://s2.loli.net/2022/11/12/N6oweukmRxWQTJ3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全属性|密钥相关属性</title>
      <link href="/2023/06/16/16-05-38/"/>
      <url>/2023/06/16/16-05-38/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="面向密钥的基础安全属性">面向密钥的基础安全属性</h2><ul><li>key freshness</li><li>(implicit) key authentication: a key is only known to the communicating agents <em>A</em> and <em>B</em> and mutually trusted parties</li><li>key confirmation of <em>A</em> to <em>B</em> is provided if <em>B</em> has assurance that agent <em>A</em> has possession of key <em>K</em></li><li>explicit key authentication = key authentication + key confirmation <em>⇒</em> expressible in terms of secrecy and agreement</li></ul><h2 id="涉及密钥泄露的安全属性">涉及密钥泄露的安全属性</h2><ul><li><strong>前向安全</strong>或<strong>前向保密</strong>（英语：Forward Secrecy，缩写：FS），有时也被称为<strong>完美前向安全</strong> （英语：Perfect Forward Secrecy，缩写：PFS），是<a href="https://baike.baidu.com/item/%E5%AF%86%E7%A0%81%E5%AD%A6/480001?fromModule=lemma_inlink">密码学</a>中通讯协议的安全属性，指的是长期使用的主<a href="https://baike.baidu.com/item/%E5%AF%86%E9%92%A5?fromModule=lemma_inlink">密钥</a>泄漏不会导致过去的<a href="https://baike.baidu.com/item/%E4%BC%9A%E8%AF%9D%E5%AF%86%E9%92%A5/8831495?fromModule=lemma_inlink">会话密钥</a>泄漏。前向安全能够保护过去进行的通讯不受<a href="https://baike.baidu.com/item/%E5%AF%86%E7%A0%81?fromModule=lemma_inlink">密码</a>或<a href="https://baike.baidu.com/item/%E5%AF%86%E9%92%A5/101144?fromModule=lemma_inlink">密钥</a>在未来暴露的威胁。如果系统具有前向安全性，就可以保证在主密钥泄露时历史通讯的安全，即使系统遭到主动攻击也是如此。</li><li>resistance to key-compromise impersonation: compromise of long-term key of an agent <em>A</em> does not allow the adversary to masquerade to <em>A</em> as a difffferent principal.</li></ul><h2 id="例子">例子</h2><p>下图协议提供前向安全性，攻击者不能获得会话密钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub><mo>=</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mi>g</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_{AB}=exp(exp(g,X),Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>，即使获得了签名密钥。</p><img src="https://s2.loli.net/2023/06/13/FwmuMEgYfNjnsWp.png" alt="image.png" style="zoom:80%;" /><p>下图协议不能提供前向安全性，攻击者获得私钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>后，可以获得会话密钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub><mo>=</mo><msup><mi>g</mi><mrow><mi>V</mi><mi>X</mi><mo>+</mo><mi>U</mi><mi>Y</mi></mrow></msup></mrow><annotation encoding="application/x-tex">K_{AB}=g^{VX+UY}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0358em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span></span></span></span></span></span></span></span></p><img src="https://s2.loli.net/2023/06/13/PR3TnfUNsgC1OqV.png" alt="image.png" style="zoom:80%;" /><p>下图协议不使用DH密钥交换也能提供前向安全性，A先生成临时对称密钥对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>k</mi><mo stretchy="false">(</mo><msub><mi>K</mi><mi>T</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pk(K_T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>k</mi><mo stretchy="false">(</mo><msub><mi>K</mi><mi>T</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sk(K_T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>攻击者不能获得会话密钥，即使签名密钥泄露</p><img src="https://s2.loli.net/2023/06/13/HjyoreINMDY523f.png" alt="image.png" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 形式化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 形式化 </tag>
            
            <tag> 安全属性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全属性|认证属性的层次结构</title>
      <link href="/2023/06/16/15-59-39/"/>
      <url>/2023/06/16/15-59-39/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>Gavin Lowe, 1997</p></blockquote><p>理想状态下，我们希望世界上的协议都是这样的，一对一认证：</p><img src="https://s2.loli.net/2023/06/19/9TxXbw58yeutBpP.png" alt="image-20230619162659073" style="zoom: 67%;" /><p>但是实际上，显示网络空间中的实体与协议是这样的：</p><img src="https://s2.loli.net/2023/06/19/QswJg63Km8vjTHd.png" alt="image-20230619162747437" style="zoom:67%;" /><p>很容易出现这种情况：</p><img src="https://s2.loli.net/2023/06/19/CDfMa5zmOt2e7w4.png" alt="image-20230619162818130" style="zoom:67%;" /><p>我们希望一一对应，相互认证：</p><img src="https://s2.loli.net/2023/06/19/S3G5EdkLbxQmB4l.png" alt="image-20230619162923180" style="zoom:67%;" /><p>于是出现了以下四个认证属性（authentication），逐渐变强。</p><h2 id="存活性（Aliveness）">存活性（Aliveness）</h2><p>发起者A认为与B完成了一轮协议会话，并且认为B为响应者，如果B<strong>确实曾经执行过该协议</strong>，则称协议对发起者A提供B的存活性认证，在满足存活性的情况下，</p><ul><li>不要求B是与A执行的该协议**（对象不要求）**</li><li>并且也不要求B是最近执行的改协议，只要B<strong>曾经</strong>参与过协议执行即可**（时间不要求）**</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">∀a b i. Claim_commit(a, b, &lt;&gt; )@i</span><br><span class="line">`⇒ (∃j id.Create_B(b, id)@j ∨ Create_A(b, id)@j)</span><br><span class="line">∨(∃X r.Rev(X)@r ∧ Honest(X)@i)</span><br></pre></td></tr></table></figure><p>存活性的要求最低，但是也有失效的可能，比如受到**反射攻击（reflection attack）**时。如下图这个协议，可能B会不参与协议：</p><img src="https://s2.loli.net/2023/06/12/MvfSmyLVcoQaBKP.png" alt="image-20230612170414022" style="zoom: 60%;" /><p>Tamarin验证如下：</p><p><img src="https://s2.loli.net/2023/06/12/3XSLQtxJkUbagfP.png" alt="image-20230612173207694"></p><h2 id="弱一致性（Weak-agreement）">弱一致性（Weak agreement）</h2><p>发起者A 认为与B完成一轮协议会话，并且认为B为响应者，如果B<strong>确实曾与A执行过该协议</strong>，则称协议发起者A提供B的弱一致性，满足弱一致性时，</p><ul><li>B与A执行过该协议，但是不一定作为响应者**（对象半要求）**</li><li><strong>（时间不要求）</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">∀a b i. Claim_commit(a, b, &lt;&gt; )@i</span><br><span class="line">⇒ (∃j.Claim_running(b, a, &lt;&gt; )@j)</span><br><span class="line">∨(∃X r.Rev(X)@r ∧ Honest(X)@i)</span><br></pre></td></tr></table></figure><p>a,b交流过，但是不要求它们扮演正确的角色</p><p>下图<strong>存活性成立，弱一致性不成立</strong>。攻击者可以修改第一条消息中未受保护的标识符A，换成C，导致B认为自己在与A通信。</p><img src="https://s2.loli.net/2023/06/12/dI5egokXNtiQ2Ac.png" alt="image-20230612163837722" style="zoom: 80%;" /><p>Tamarin验证如下：</p><p><img src="https://s2.loli.net/2023/06/12/C7ls4UdOqDkHTfF.png" alt="image-20230612164054692"></p><h2 id="非单射一致性-No-injective-agreement">非单射一致性 (No-injective agreement)</h2><p>发起者A认为与响应者B完成了一轮协议会话，如果B确实作为响应者曾与A执行过该协议，并且两个主体对变量集ds中的所有变量的值<strong>都是统一认可的</strong>，则称协议发起者A提供B在变量集ds上的非单射一致性。</p><p>那么满足非单射一致性的协议中，发起者A的协议轮和响应者B的协议轮<strong>不要求一一对应</strong>，有可能A发起了两次会话，但是B只运行了一次，另一次由攻击者重放第一轮会话冒充B完成，也有可能A只发送了一次会话，但攻击者重放第一轮会话冒充A， 让B运行两次，另外，有些协议不满足非单射一致性是因为攻击者成功误导两个参与主体，使得两个主体在协议运行结束后，变量集ds中的某些变量的值不同。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">∀a b t i. Claim_commit(a, b, &lt;A, B,t&gt; )@i</span><br><span class="line">⇒ (∃j.Claim_running(b, a, &lt;A, B,t&gt; )@j)</span><br><span class="line">∨(∃X r.Rev(X)@r ∧ Honest(X)@i)</span><br></pre></td></tr></table></figure><h2 id="单射一致性-Injective-agreement">单射一致性(Injective agreement)</h2><p>发起者A认为与响应者B完成了一轮协议的会话，如果B确实作为响应者曾与A执行过该协议，并且两个主体对变量集ds中的所有变量的值<strong>都是统一认可的</strong>，并且A的每一轮会话都是唯一对应B的一轮会话，则称协议对发起者A提供B在变量集ds上的单射一致性。也称作强一致性，在电子商务相关的协议中A和B的协议之间的一一对应的关系非常的重要的。</p><p>所以说上面的区别主要就是在发起者A有没有存在<strong>唯一对应的应答</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">∀a b t i. Claim_commit(a, b, &lt;A, B,t&gt; )@i</span><br><span class="line">⇒ (∃j.Claim_running(b, a, &lt;A, B,t&gt; )@j ∧ j &lt; i</span><br><span class="line">∧¬(∃a2b2i2.Claim_commit(a2, b2, &lt;A, B,t&gt; )@i2</span><br><span class="line">∧¬(i2 = i)))</span><br><span class="line">∨(∃X r.Rev(X)@r ∧ Honest(X)@i)</span><br></pre></td></tr></table></figure><p>下图满足非单射一致性，不满足单射一致性，攻击者可以重放消息。</p><img src="https://s2.loli.net/2023/06/12/62FsKjoBtufbCSV.png" alt="image-20230612161442742" style="zoom:67%;" /><p>Tamarin验证如下：</p><p><img src="https://s2.loli.net/2023/06/12/qoRvf4ZjAI1M3Bm.png" alt="image-20230612162152502"></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 形式化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 形式化 </tag>
            
            <tag> 安全属性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vlog|夜爬华山</title>
      <link href="/2023/05/06/15-05-17/"/>
      <url>/2023/05/06/15-05-17/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div align="center" class="aspect-ratio">  <iframe    src="https://player.bilibili.com/player.html?aid=995678206&&page=1&as_wide=1&high_quality=1&danmaku=0"    scrolling="no"    border="0"    frameborder="no"    framespacing="0"    high_quality="1"    danmaku="1"    allowfullscreen="true"  ></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 城市 </tag>
            
            <tag> 山 </tag>
            
            <tag> 旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式化3|分离逻辑</title>
      <link href="/2023/03/22/18-15-25/"/>
      <url>/2023/03/22/18-15-25/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-分离逻辑基本思想">1. 分离逻辑基本思想</h2><blockquote><p>Reynolds JC. Separation logic: A logic for shared mutable data structures. In: Proc. of the LICS 2002. Copenhagen, 2002. 55−74.</p><p>Reynolds JC. An overview of separation logic. In: Proc. of the Verified Software: Theories, Tools, Experiments. Zurich, 2005.</p><p>460−469.</p></blockquote><p>分离逻辑是霍尔逻辑的一种扩展。霍尔逻辑是广泛应用的程序验证逻辑系统，用于对命令式语言程序进行推理验证，其基本思想是：在代码段及其调用者之间构建一种合同似的规格说明，由一个前置条件和一个后置条件构成。前置条件是一个<strong>断言（assert）</strong>，描述这个代码段执行前程序状态必须满足的条件；后置条件也是一个断言，描述在代码段正确运行后程序状态所需要满足的条件，调用者可以确信在代码段执行结束后这个状态条件为真。</p><p>分离逻辑对程序的推理仍然是采用<strong>霍尔三元组</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>P</mi><mo stretchy="false">}</mo><mi>C</mi><mo stretchy="false">{</mo><mi>Q</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{P\} C\{Q\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">}</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">{</span><span class="mord mathnormal">Q</span><span class="mclose">}</span></span></span></span>，其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>表示前置条件，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>表示后置条件，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>表示代码段。例如：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mo>=</mo><mi>N</mi><mo stretchy="false">}</mo><mtext> code </mtext><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mo>=</mo><mi>N</mi><mo>∧</mo><mi>y</mi><mo>=</mo><mo>=</mo><mi>N</mi><mo stretchy="false">!</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{x==N\} \text { code }\{x==N \wedge y==N !\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">}</span><span class="mord text"><span class="mord"> code </span></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">!}</span></span></span></span></span></p><p>可以应用到”将变量 x 值的阶乘赋值于 y”程序的验证中。</p><p>在分离逻辑中,前置条件和后置条件中的程序状态<strong>主要由栈<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>和堆<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>构成</strong>，栈是变量到值的映射，而堆是有限的地址集合到值的映射。在程序验证时，可以<strong>将栈看作对寄存器内容的描述，而堆是对可寻址内存内容的描述</strong>。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo><mover><mo><mo>=</mo></mo><mtext> def </mtext></mover></mo><mtext> Variables </mtext><mo>→</mo><mtext> Values, </mtext><mi>H</mi><mo><mover><mo><mo>=</mo></mo><mtext> def </mtext></mover></mo><mtext> Addresses </mtext><mo>→</mo><msub><mrow></mrow><mtext>fin </mtext></msub><mtext> Values, States </mtext><mo><mover><mo><mo>=</mo></mo><mtext> def </mtext></mover></mo><mi>S</mi><mo>×</mo><mi>H</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">S \stackrel{\text { def }}{=} \text { Variables } \rightarrow \text { Values, } H \stackrel{\text { def }}{=} \text { Addresses } \rightarrow{ }_{\text {fin }} \text { Values, States } \stackrel{\text { def }}{=} S \times H .</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.153em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.153em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">=</span></span></span><span style="top:-3.5669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight"> def </span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord"> Variables </span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3474em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord"> Values, </span></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.153em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">=</span></span></span><span style="top:-3.5669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight"> def </span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord"> Addresses </span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3474em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">fin </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> Values, States </span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.153em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">=</span></span></span><span style="top:-3.5669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight"> def </span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">.</span></span></span></span></span></p><p>分离逻辑对霍尔逻辑的最重要扩展,在于引入了两个新的分离逻辑连接词：<strong>分离合取（Separating Conjunction）</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord">∗</span></span></span></span>，<strong>分离蕴含（Separating Implication）</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mo>∗</mo></mrow><annotation encoding="application/x-tex">-*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">∗</span></span></span></span>，语义形式化表示如下：</p><p>如果令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>表示栈，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>表示堆，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>0</mn></msub><mo>⊥</mo><msub><mi>h</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">h_0 \perp h_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示堆<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">h_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">h_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>不相交，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>0</mn></msub><mo>⋅</mo><msub><mi>h</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">h_0 \cdot h_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示堆<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">h_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">h_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的联合，则</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><msup><mi>P</mi><mo>∗</mo></msup><mi>Q</mi><mo fence="true">]</mo></mrow><mi>s</mi><mi>h</mi><mo><mover><mo><mo>=</mo></mo><mtext> def </mtext></mover></mo><mi mathvariant="normal">∃</mi><msub><mi>h</mi><mn>0</mn></msub><msub><mi>h</mi><mn>1</mn></msub><mo>⋅</mo><msub><mi>h</mi><mn>0</mn></msub><mo>⊥</mo><msub><mi>h</mi><mn>1</mn></msub><mtext> and </mtext><msub><mi>h</mi><mn>0</mn></msub><mo>⋅</mo><msub><mi>h</mi><mn>1</mn></msub><mo>=</mo><mi>h</mi><mtext> and </mtext><mi>P</mi><mi>s</mi><msub><mi>h</mi><mn>0</mn></msub><mtext> and </mtext><mi>Q</mi><mi>s</mi><msub><mi>h</mi><mn>1</mn></msub><mtext>. </mtext></mrow><annotation encoding="application/x-tex">\left[P^* Q\right] s h \stackrel{\text { def }}{=} \exists h_0 h_1 \cdot h_0 \perp h_1 \text { and } h_0 \cdot h_1=h \text { and } P s h_0 \text { and } Q s h_1 \text {. }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.403em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal">Q</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.153em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">=</span></span></span><span style="top:-3.5669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight"> def </span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord">∃</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> and </span></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">h</span><span class="mord text"><span class="mord"> and </span></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">s</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> and </span></span><span class="mord mathnormal">Q</span><span class="mord mathnormal">s</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord">. </span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">[</mo><msup><mi>P</mi><mo>∗</mo></msup><mi>Q</mi><mo fence="true">]</mo></mrow><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">\left[P^* Q\right] s h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal">Q</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span></span></span></span>断言整个堆<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>被分成两个不相交的部分<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">h_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">h_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，并且对子堆<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">h_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>断言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>成立，而对子堆<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">h_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>断言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>成立。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">[</mo><mi>P</mi><mo>−</mo><mo>∗</mo><mi>Q</mi><mo stretchy="false">]</mo><mi>s</mi><mi>h</mi><mo><mover><mo><mo>=</mo></mo><mtext> def </mtext></mover></mo><mi mathvariant="normal">∀</mi><msup><mi>h</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>⋅</mo><mrow><mo fence="true">(</mo><msup><mi>h</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>⊥</mo><mi>h</mi><mtext> and </mtext><mi>P</mi><mi>s</mi><msup><mi>h</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo fence="true">)</mo></mrow><mtext> implies </mtext><mi>Q</mi><mi>s</mi><mrow><mo fence="true">(</mo><mi>h</mi><mo>⋅</mo><msup><mi>h</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo fence="true">)</mo></mrow><mtext>. </mtext></mrow><annotation encoding="application/x-tex">[P-* Q] s h \stackrel{\text { def }}{=} \forall h^{\prime} \cdot\left(h^{\prime} \perp h \text { and } P s h^{\prime}\right) \text { implies } Q s\left(h \cdot h^{\prime}\right) \text {. }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.403em;vertical-align:-0.25em;"></span><span class="mord">∗</span><span class="mord mathnormal">Q</span><span class="mclose">]</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.153em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">=</span></span></span><span style="top:-3.5669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight"> def </span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">h</span><span class="mord text"><span class="mord"> and </span></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">s</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord"> implies </span></span><span class="mord mathnormal">Q</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">. </span></span></span></span></span></span></p><p>分离蕴含表示，如果当前堆<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>通过一个分离的部分<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>h</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">h^{\prime}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>扩展，并且对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>h</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">h^{\prime}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>断言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>成立，则对扩展后的堆<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mi>h</mi><mo>⋅</mo><msup><mi>h</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(h \cdot h^{\prime}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>断言<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>成立。</p><p>通过使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord">∗</span></span></span></span>用而不是通常的布尔连接符<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∧</span></span></span></span>，确保<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>不出现别名混淆，即多个变量指向同一地址。参考下图理解。</p><p><img src="https://s2.loli.net/2023/04/04/h5JBWLEZoq2A4Iu.png" alt="分离与、逻辑与"></p><h2 id="2-分离逻辑的语法和断言语言">2. 分离逻辑的语法和断言语言</h2><p>了解分离逻辑的对计算机存储的抽象，便可以如下定义分离逻辑的语法的BNF表示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>v</mi><mo>∈</mo><mi>V</mi><mo separator="true">,</mo><mi>n</mi><mo>∈</mo><mtext> Values </mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext> Integer Expns </mtext><mspace width="1em"/><mi>i</mi><mo>:</mo><mo>:</mo><mo>=</mo><mi>v</mi><mi mathvariant="normal">∣</mi><mi>n</mi><mi mathvariant="normal">∣</mi><msub><mi>i</mi><mn>1</mn></msub><mo>+</mo><msub><mi>i</mi><mn>2</mn></msub><mrow><mo fence="true">∣</mo><msub><mi>i</mi><mn>1</mn></msub><mo>−</mo><msub><mi>i</mi><mn>2</mn></msub><mo fence="true">∣</mo></mrow><msub><mi>i</mi><mn>1</mn></msub><mo>×</mo><msub><mi>i</mi><mn>2</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext> Pointer Expns </mtext><mspace width="1em"/><mi>k</mi><mo>:</mo><mo>:</mo><mo>=</mo><mi>v</mi><mi mathvariant="normal">∣</mi><mi>v</mi><mo separator="true">,</mo><mi>n</mi><mi mathvariant="normal">∣</mi><mtext> null </mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext> Boolean Expns </mtext><mspace width="1em"/><mi>b</mi><mo>:</mo><mo>:</mo><mo>=</mo><mi>T</mi><mi mathvariant="normal">∣</mi><mi>F</mi><mi mathvariant="normal">∣</mi><msub><mi>i</mi><mn>1</mn></msub><mo>=</mo><msub><mi>i</mi><mn>2</mn></msub><mrow><mo fence="true">∣</mo><msub><mi>k</mi><mn>1</mn></msub><mo>=</mo><msub><mi>k</mi><mn>2</mn></msub><mo fence="true">∣</mo></mrow><msub><mi>i</mi><mn>1</mn></msub><mo>⩽</mo><msub><mi>i</mi><mn>2</mn></msub><mo>∣</mo><msub><mi>b</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi><mi>b</mi><mi mathvariant="normal">∣</mi><msub><mi>b</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>b</mi><mn>2</mn></msub><mo>∣</mo><msub><mi>b</mi><mn>1</mn></msub><mo>→</mo><msub><mi>b</mi><mn>2</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext> Expressions </mtext><mspace width="1em"/><mi>e</mi><mo>:</mo><mo>:</mo><mo>=</mo><mi>i</mi><mi mathvariant="normal">∣</mi><mi>b</mi><mi mathvariant="normal">∣</mi><mi>k</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext> Assertions </mtext><mspace width="1em"/><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo>:</mo><mo>:</mo><mo>=</mo><mi>b</mi><mi mathvariant="normal">∣</mi><mi>k</mi><mo>↦</mo><mi>e</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">emp</mi><mo>⁡</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mo>∧</mo><mi>q</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>∨</mo><mi>q</mi><mo>∣</mo><mi>p</mi><mo>⇒</mo><mi>q</mi><mrow><mo fence="true">∣</mo><msup><mi>p</mi><mo>∗</mo></msup><mi>q</mi><mo fence="true">∣</mo></mrow><mi>p</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mo>∗</mo><mi>q</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∀</mi><mi>v</mi><mo>⋅</mo><mi>p</mi><mo>∣</mo><mi mathvariant="normal">∃</mi><mi>v</mi><mo>⋅</mo><mi>p</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}&amp; v \in V, n \in \text { Values } \\&amp; \text { Integer Expns } \quad i::=v|n| i_1+i_2\left|i_1-i_2\right| i_1 \times i_2 \\&amp; \text { Pointer Expns } \quad k::=v|v, n| \text { null } \\&amp; \text { Boolean Expns } \quad b::=T|F| i_1=i_2\left|k_1=k_2\right| i_1 \leqslant i_2 \mid b_1 \vee b_2|b| b_1 \wedge b_2 \mid b_1 \rightarrow b_2 \\&amp; \text { Expressions } \quad e::=i|b| k \\&amp; \text { Assertions } \quad p, q::=b|k \mapsto e| \operatorname{emp}|p \wedge q| p \vee q \mid p \Rightarrow  q\left|p^* q\right| p|p-* q| \forall v \cdot p \mid \exists v \cdot p \\&amp;\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:10.5em;vertical-align:-5em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:5.5em;"><span style="top:-7.5em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-6em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-4.5em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-3em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-1.5em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:0em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:1.5em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:5em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:5.5em;"><span style="top:-7.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord text"><span class="mord"> Values </span></span></span></span><span style="top:-6.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord"> Integer Expns </span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">::=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">∣</span><span class="mord mathnormal">n</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord"> Pointer Expns </span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">::=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord">∣</span><span class="mord text"><span class="mord"> null </span></span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord"> Boolean Expns </span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">::=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal">b</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord"> Expressions </span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">::=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">i</span><span class="mord">∣</span><span class="mord mathnormal">b</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-0.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord"> Assertions </span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">::=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">b</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">e</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mord mathrm">emp</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord">∣</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mord">∣</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">∗</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord">∣∀</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">∃</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">p</span></span></span><span style="top:1.34em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:5em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>表示变量。</p><p>分离逻辑对于Hoare逻辑的拓展主要是通过引入4种新的断言形式，以细化对计算机系统存储状态的描述。下面主要介绍这些新引入的断言：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext> Assertions </mtext><mspace width="1em"/><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo>:</mo><mo>:</mo><mo>=</mo><mo>⋯</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtable rowspacing="0.16em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>∣</mo><mi>e</mi><mi>m</mi><mi>p</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> 空堆 </mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>∣</mo><mi>k</mi><mo>↦</mo><mi>e</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> 单堆 </mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>∣</mo><msup><mi>p</mi><mo>∗</mo></msup><mi>q</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> 分离合取 </mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>∣</mo><mi>p</mi><mo>−</mo><mo>∗</mo><mi>q</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> 分离蕴含 </mtext></mstyle></mtd></mtr></mtable></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}&amp;\text { Assertions } \quad p, q::=\cdots\\&amp;\begin{array}{ll}\mid e m p &amp; \text { 空堆 } \\\mid k \mapsto e &amp; \text { 单堆 } \\\mid p^* q &amp; \text { 分离合取 } \\\mid p-* q &amp; \text { 分离蕴含 }\end{array}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.6em;vertical-align:-3.05em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.55em;"><span style="top:-7.36em;"><span class="pstrut" style="height:4.65em;"></span><span class="mord"></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:4.65em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.05em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.55em;"><span style="top:-7.36em;"><span class="pstrut" style="height:4.65em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord"> Assertions </span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">::=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner">⋯</span></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:4.65em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">e</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">∗</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">空堆</span><span class="mord"> </span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">单堆</span><span class="mord"> </span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">分离合取</span><span class="mord"> </span></span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">分离蕴含</span><span class="mord"> </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.05em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>空堆即堆<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>为空；</p><h2 id="3-分离逻辑的推导规则">3. 分离逻辑的推导规则</h2><p>作为一个形式化系统的推理工具，推导规则在验证过程中起到了很重要的作用。下图包含了分离逻辑中的部分规则，这些规则被分为描述基础数据更改操作的小公理和用于模块化推理的局部推理规则。推理规则可以被理解为“如果横线上面的可以被推导出来，那么就可以推导出横线下的结果”，而公理是已知的可满足公式。</p><img src="https://s2.loli.net/2023/04/04/CIiHbygNOuGlVFE.png" alt="分离逻辑的部分推导规则" style="zoom: 80%;" /><ol><li>第一条公理表示如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>之前指向某个值，把其地址对应的内容改为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>将指向新的值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>；</li><li>第二条公理表示如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>之前存储了值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，用变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>读取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>地址所对应的内容时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>将会暂存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>的值。这条公理为我们区分值在寄存器和堆中的不同描述：由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>只是将值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>用作暂存，不会被分配地址空间，也就不会对堆产生更改，因此用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y==x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>表示，该公理假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>不出现在表达式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>中；</li><li>第三条公理表示如果开始时没有堆，执行分配操作后就会产生大小为1的堆；</li><li>反之，第四条公理表示如果开始时是大小为1的堆，那么执行释放操作后将以空堆作为结束。</li></ol><p>从某种意义上，小公理涵盖了它们所描述语句的关键信息。直观来讲，这些简单的语句每次只更新或访问一个内存单元，那么仅描述这个单元格发生什么就足够了，以此可以运用就地推理的策略对程序状态进行验证，即仅在上一个状态的基础上作更新。但又因为小公理过于简单，所以它暂时不能基于系统全局的状态进行推理。</p><p>框架规则(Frame Rule) 则为分离逻辑提供了从局部推导到全局推导的逻辑上的帮助。它允许我们将推理从一个拓展到多个存储单元，因此，仅作用于一个单元的小公理便不会再是一种限制，反而成为了一种简洁直观的描述。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 形式化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 形式化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式化2|霍尔逻辑</title>
      <link href="/2023/03/22/18-02-23/"/>
      <url>/2023/03/22/18-02-23/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>参考文献：</p><p>Hoare C A R. An axiomatic basis for computer programming[J]. Communications of the ACM, 1969, 12(10): 576-580. <a href="https://dl.acm.org/doi/10.1145/363235.363259">https://dl.acm.org/doi/10.1145/363235.363259</a></p></blockquote><h2 id="程序语义与霍尔逻辑">程序语义与霍尔逻辑</h2><p>为什么对属性的验证可以转化为逻辑公式的可满足性？这两者真的等价吗？</p><p>对于一个可执行的C语言程序而言，比较直观的<strong>语义</strong>（Semantics）理解应该是，内存中有一部分存储着程序的二进制<strong>指令</strong>（Command），然后有一个指向当前执行指令的特殊指针变量（即<strong>程序计数器</strong>，Program Counter，pc），还有一部分存储着每个变量的值（<strong>栈</strong>和<strong>堆</strong>，Stack and Heap）。 随着程序指令的依次执行，内存的状态发生变化，比如赋值语句导致变量的值改变，控制流语句产生指令跳转，导致pc发生变化。 将这个过程<strong>形式化</strong>地定义出来，就是直观的<strong>操作语义</strong>（Operational Semantics）。 它定义了一个<strong>状态机</strong>（State Machine），将程序每一步执行所产生的<strong>影响</strong>，反应到状态机的<strong>状态变化</strong>上。</p><p>这样的程序语义和程序的实际运行情况非常切合，但却<strong>不利于</strong>逻辑和数学表达。 因此，在进行程序分析和验证时，我们会求诸于更加贴近于数学表达的<strong>公理语义</strong>（Axiomatic Semantics）。 <strong>霍尔逻辑</strong>（Floyd-Hoare Logic）便是一种典型的建立在<strong>谓词逻辑</strong>基础上的公理语义。 在其基础上，我们可以在程序代码和谓词逻辑公式之间，建立起「等语义关系」的转化，从而确保我们的程序验证方法是有效的。</p><h2 id="霍尔三元组">霍尔三元组</h2><p>霍尔逻辑核心概念是霍尔三元组，记为以下形式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">{</mo><mi>P</mi><mo stretchy="false">}</mo><mi>c</mi><mo stretchy="false">{</mo><mi>Q</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{P\}c\{Q\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">}</span><span class="mord mathnormal">c</span><span class="mopen">{</span><span class="mord mathnormal">Q</span><span class="mclose">}</span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>是一阶逻辑公式。分别表示<strong>前置条件（pre-condition）<strong>和</strong>后置条件（post-condition）</strong>。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>表示一段程序源代码。霍尔三元组的含义是，假定前置条件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>是有效的，那么在执行完程序<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>后，后置条件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>将会是有效的。例如如下非形式化的霍尔三元组：</p><img src="https://s2.loli.net/2023/04/04/VhvM2owJkZXHuCr.png" alt="image-20230404201121108" style="zoom:80%;" /><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">gcd</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{gcd}(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">gcd</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>是求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>的最大公约数的函数。这个霍尔三元组说明，只要输入是两个正整数，那么就能计算出两者的最大公约数，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">gcd</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{gcd}(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">gcd</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>函数实现的功能是正确的。</p><p>再来一个例子，交换两个数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mrow><mo fence="true">{</mo><mi>x</mi><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub><mo>∧</mo><mi>y</mi><mo>=</mo><msub><mi>y</mi><mn>0</mn></msub><mo fence="true">}</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi mathvariant="normal">x</mi><mo>=</mo><mi mathvariant="normal">x</mi><mo>+</mo><mi mathvariant="normal">y</mi><mo separator="true">;</mo><mi mathvariant="normal">y</mi><mo>=</mo><mi mathvariant="normal">x</mi><mo>−</mo><mi mathvariant="normal">y</mi><mo separator="true">;</mo><mi mathvariant="normal">x</mi><mo>=</mo><mi mathvariant="normal">x</mi><mo>−</mo><mi mathvariant="normal">y</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mrow><mo fence="true">{</mo><mi>x</mi><mo>=</mo><msub><mi>y</mi><mn>0</mn></msub><mo>∧</mo><mi>y</mi><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub><mo fence="true">}</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}&amp; \left\{x=x_0 \wedge y=y_0\right\} \\&amp; \mathrm{x}=\mathrm{x}+\mathrm{y} ; \mathrm{y}=\mathrm{x}-\mathrm{y} ; \mathrm{x}=\mathrm{x}-\mathrm{y} \\&amp; \left\{x=y_0 \wedge y=x_0\right\}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.5em;vertical-align:-2em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.5em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-3em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-1.5em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathrm">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">y</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">y</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">y</span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 形式化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 形式化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式化1|概述</title>
      <link href="/2023/03/21/17-13-40/"/>
      <url>/2023/03/21/17-13-40/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-什么是形式化">1. 什么是形式化</h2><p>20世纪70年代末80年代初，Needham和Sehrieder将形式化方法应用于安全协议分析。Dolev和Yao在此领域开始了真正的实际工作，并且Dolev，Even和Karp为验证一些有限种类的协议安全性开发了一套算法。直到20世纪90年代初，形式化方法在密码协议中的应用才变得非常流行。在密码协议中运用形式化的分析技术时，研究者发现了以前未能发现的安全缺陷，随之许多安全协议分析工具开发出来了，如Miller的询问器、Meadow的NRL协议分析仪以及Longley-Rigby工具等等。</p><p><strong>一句话概括，形式化验证是用形式化的数学方法，来证明或者反证系统满足需求规范。</strong></p><h2 id="2-为什么要用形式化">2. 为什么要用形式化</h2><p>安全协议的形式化分析需要对外部环境进行评价并在此基础上模拟运行，当网络中存在的攻击者时，要提出具体化的模型。假设安全协议外部环境中包括<strong>消息的发送方，消息的接受方和协议的攻击方</strong>，还包括各种<strong>规则</strong>，参与协议的各方使用规则来参与其中。攻击者可能会进行级联、拆分、加密和解密消息（根据DY模型）。具体的表现有以下几种形式：</p><ul><li>猜测协议中传递的消息；</li><li>转发消息到其指定的接收者处；</li><li>使消息到达目的地的时间推迟；</li></ul><p>因此，确保安全协议的安全运行十分重要，因为在实际运行过程中，安全协议产生缺陷的原因多种多样，且对安全协议的攻击方式变化无穷，所以安全协议的安全性是一个很难解决的问题，许多广泛应用的安全协议后来都被发现存在缺陷。</p><p>最初，人们是<strong>基于经验和单纯的软件测试</strong>采用攻击检验的方法来分析协议安全性。但由于安全协议运行的外部环境十分复杂多变，对安全协议新的攻击方法越来越多。所以，仅用人工的方法很难识别产生的错误。因此，必须采用形式化的方法和攻击来对密码协议的安全性进行分析。形式化分析就是采用数学或逻辑模型，通过有效的程序来分析系统及其条件，以此来确定一种在系统满足条件情况下所得的证明是否正确的数学理论和方法。</p><p>因为形式化的数学理论基础，所以其能更精确规范密码协议的安全特性，且没有歧义。因此采用形式化方法分析密码协议，验证密码协议的正确性。形式化方法包含的内容有：</p><ul><li>安全协议分析的形式化模型；</li><li>用规范的语言表述密码协议的安全特性；</li><li>用形式化语义来解释密码协议及其安全特性；</li><li>通过验证技术来确定密码协议是否具备所需的安全特性。</li></ul><h2 id="3-形式化方法构成">3. 形式化方法构成</h2><blockquote><p>《形式化方法导论》，张广泉</p></blockquote><p>形式化方法主要由三方面构成，包括对系统进行描述的系统建模，定义系统需要满足的属性的形式规约和证明系统模型满足相应属性的形式验证。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart LR    A(系统建模) --&gt;B(形式规约)    B --&gt; C(形式验证)  </pre></div><h3 id="3-1-系统建模">3.1 系统建模</h3><p>系统建模是对所需要进行验证的系统进行抽象描述的过程。</p><p>计算机系统最初是<strong>串行的</strong>，它具有封闭性、顺序性、可再现性的特征，可以通过输入输出关系来对系统进行描绘。而随着具有<strong>不确定性和并发性</strong>的系统出现，之前的方法就不要再适用。</p><p>合理的抽象模型可以帮助人们更好地抓住系统的本质并加以理解，方便之后对系统进行规约和验证。因此，系统模型的抽象粒度很关键，模型过于抽象不能体现其安全属性，过于具体又可能产生冗余。</p><p>目前有许多方法来描述并发系统的形式化建模方法。</p><ul><li>Petri网</li></ul><p>Petri网是一种既能用来分析系统性质，又能运用图形直观地描绘系统结构的工具。</p><ul><li>各种状态迁移系统</li></ul><p>由于并发系统的不确定性，为了能更好地表示并发，这个模型的各个迁移过程之间采用交错执行，并且这种交错执行的顺序也具有不确定性。</p><p>比较著名的有基于进程演算的CSP模型和CCS模型等。</p><ul><li>自动机（状态机）</li></ul><p>自动机也是一种常见的抽象模型，其中有限自动机是这一领域中的基础。有限自动机通常也被称作有限状态机，它在软件设计中的应用非常广泛，主要用来说明一个对象在它的生命周期内所能经历的一系列状态以及它能够对外界的事件产生的反应。状态图是状态机最为常见的描绘方式。</p><h3 id="3-2-形式规约">3.2 形式规约</h3><p>在软件开发的过程中，第一步就是确定需求，并且需求需要是清晰的、明确的、没有歧义的。进行软件的实现必须是按照需求来完成的，判断开发得到的系统是否合适，首先就是需要验证它是否满足一开始所确定的需求。形式规约就是使用精确的形式化语言对系统需要满足的属性进行准确定义的过程。</p><p>形式规约同样也存在从面向串行系统到面向并发系统的发展历程。在串行程序中，从系统的初始状态到系统最终状态的过程是相对固定的，采用 <strong>Floyd 前后断言法、一阶逻辑</strong>等方法来进行形式规约在当时是比较好的选择。</p><p>对于并发系统而言，它存在着不确定性，其状态的改变更为复杂，<strong>时序逻辑</strong>能够更好地对它进行规约。除了包含常见的与或非等表现逻辑关系的联结词外，时序逻辑还包含了一些用来表示时间上的关系的时序算子。并发系统最常见的属性有表示坏的事情永远不会发生的<strong>安全性</strong>和表示好的事情最终会发生的<strong>活性</strong>，这些属性中出现的“永不”和“最终”这种与时间存在关系的表述方法都可以很好地用时序逻辑来进行表达。</p><h3 id="3-3-形式验证">3.3 形式验证</h3><p>形式验证就是检验根据系统所建立的模型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>是否满足针对这个系统所提出的需求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span> ，即验证<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∣</mo><mo>=</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">S \mid=\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span> 。</p><p>形式验证的方法主要分为根据逻辑公理进行推理的<strong>演绎类方法</strong>和进行穷尽搜索的<strong>模型检测类方法</strong>。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LR    A(形式化验证) --&gt;B(演绎类)    A --&gt;MC    subgraph 方法    B    MC(模型检测)    end    subgraph 适用范围    YX(有限状态并发系统)    JH(几乎所有系统)    end        B --&gt;YX    MC(模型检测) --&gt;JH        subgraph 优点    GD(高度抽象表达能力强大)    YZ(验证自动进行)    end        YX--&gt;GD    JH--&gt;YZ        subgraph 缺点    XY(需要验证者有良好的数学训练和经验)    BZ(需要解决状态爆炸问题)    end        GD--&gt;XY    YZ--&gt;BZ  </pre></div><ul><li>演绎类</li></ul><p>演绎类的方法将需要验证的性质看成是一个数学定理来进行证明，既可以验证状态有限的系统，也可以通过归纳的方法来应对状态数量庞大甚至是无限状态空间的情况。但是这类方法难以实现完全自动化，当需要验证的系统比较复杂时，这类方法就显得效率低下了。而且人工验证除了费时费力以外，还存在着使用方法是否恰当的疑问，当使用的方法不当时可能导致无法正确进行推理。</p><ul><li>模型检测</li></ul><p>模型检测类方法则是会对状态空间内所有可能的路径进行搜索，来判断系统所有可能的行为和预期的属性是否都能够达成一致，如果一致的话则返回正确的结论，如果不一致则返回一个反例。这类方法由于它的自动化程度高，目前被运用于许多领域，比如安全协议的研究和软硬件系统设计的验证。然而，正是因为传统模型检测的方法会覆盖到所有可能的状态，所以由于数量太多而产生的状态空间爆炸的问题一直是这类方法使用过程中容易遇到的关键性问题。研究人员也针对这个问题提出了一些解决方案，比如使用二叉决策图来表示状态空间以此增加对可验证状态数量的支持的符号模型检测、限定检验范围的有界模型检测等方法，通过这些方法可以简化整体的状态空间或者有针对性地检测部分状态空间。</p><h2 id="4-攻击者模型">4. 攻击者模型</h2><h3 id="4-1-Dolve-Yao模型">4.1 Dolve-Yao模型</h3><blockquote><p>DOLEV D, YAO A. On the security of public key protocols[J]. IEEE Transactions on information theory, 1983, 29(2): 198-208.</p></blockquote><p>这是如今最常见的攻击者模型，它假设<strong>攻击者不具备破解密码算法</strong>的能力。如果攻击者想要获得加密的秘密，他必须使用正确的密钥来对它进行解密，同时假设在初始阶段，攻击者并不知道任何合法参与者所拥有的秘密消息。并且攻击者还拥有以下能力：</p><ol><li>攻击者可以窃听网络消息，在不被发现的情况下阻止并截取所有网络中的消息；</li><li>攻击者可以储存自己获得的或者创造的消息；</li><li>攻击者可以伪造消息，发送消息；</li><li>攻击者可以作为合法的协议参与者参与协议。</li></ol><p>也就是说，攻击者可以拥有控制整个网络的能力。</p><p>目前大多数的形式化分析工具都是基于 Dolve-Yao 模型设计的。</p><h3 id="4-2-eCK模型">4.2 eCK模型</h3><blockquote><p>SCHMIDT B. Formal analysis of key exchange protocols and physical protocols[J]. Analytical Chemistry, 2013, 64(13): 665A-671A.</p><p>倪亮, 陈恭亮, 李建华. eCK 模型的安全性分析[J]. 山东大学学报:理学版, 2013</p></blockquote><p>eCK 模型是针对密钥协商过程被提出的，它提供了一个比 Dolve-Yao 模型更强大的攻击模型。在 eCK 模型中，合法参与者和攻击者被描述为概率多项式时间图灵机。</p><blockquote><p>在计算复杂理论内，<strong>机率图灵机</strong>是一个非决定型图灵机，在每个转折点根据某种概率分布随机选择某种可行的转变</p></blockquote><p>除了拥有 Dolve-Yao 模型下的能力外，敌手在与挑战者进行游戏时，还被允许拥有以下能力：</p><ol><li>攻击者可以获取参与者的长期密钥；</li><li>攻击者可以获取会话中参与者的临时秘密；</li><li>攻击者可以获取会话中计算得到的会话密钥。</li></ol><p>在一个双方的密钥协商中，一般涉及到双方的长期密钥和临时秘密这四块秘密信息，只要每个参与者仍有至少一个秘密未被泄露，则称这个密钥协商过程在 eCK 模型下是安全的。而 eCK 模型下的安全应该满足以下性质：</p><ol><li>当敌手未获取到参与协议的合法实体的长期私钥时，它无法仿冒这个实体的身份。</li><li>协议进行一次运行则只会产生唯一一个独立的会话密钥。即使敌手掌握了在其它会话中产生的密钥，也无法得知当前会话产生的密钥。</li><li>即使所有代理的长期私钥都被敌手获知，至少还能保证前几次会话的密钥是安全的。</li><li>当敌手得知了某个合法参与者的长期私钥，它便可以假冒这个参与者和其它合法参与者进行通信。</li><li>当协商得到会话密钥后，实体并不会错认与之生成会话密钥的对象。</li><li>即使敌手获取到会话中传递的临时秘密，它仍然无法得到会话时使用的密钥，也无法得到其它会话中使用的密钥。</li></ol><h2 id="5-常见形式化方法及工具">5. 常见形式化方法及工具</h2><table><thead>  <tr>    <th rowspan="2">形式化工具</th>    <th rowspan="2">模型</th>    <th rowspan="2">证明</th>    <th rowspan="2">安全属性</th>    <th colspan="4">分析能力</th>  </tr>  <tr>    <th>无限状态空间</th>    <th>代数运算</th>    <th>自动化</th>    <th>可视化</th>  </tr></thead><tbody>  <tr>    <td>BAN逻辑</td>    <td>逻辑公式</td>    <td>基于推理的信念</td>    <td>认证性</td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>Paulson归纳法</td>    <td>“trace”集合</td>    <td>归纳法</td>    <td>机密性、认证性</td>    <td>√</td>    <td></td>    <td>√</td>    <td></td>  </tr>  <tr>    <td>FDR</td>    <td>CSP</td>    <td>状态机</td>    <td>机密性、认证性</td>    <td></td>    <td></td>    <td>√</td>    <td></td>  </tr>  <tr>    <td>AVISPA</td>    <td>HLPSL</td>    <td>状态机</td>    <td>机密性、认证性</td>    <td>√</td>    <td>exp，xor（作为函<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数）</td>    <td>√</td>    <td>消息序列图和攻击图</td>  </tr>  <tr>    <td>Scyther</td>    <td>线性角色脚本</td>    <td>状态机</td>    <td>机密性、认证性</td>    <td>√</td>    <td></td>    <td>√</td>    <td>攻击图</td>  </tr>  <tr>    <td>ProVerif</td>    <td>应用PI演算</td>    <td>Horn子句</td>    <td>机密性、认证性</td>    <td>√</td>    <td></td>    <td>√</td>    <td>攻击图</td>  </tr>  <tr>    <td>Tamarin</td>    <td>多重集重写规则</td>    <td>状态机</td>    <td>可执行性、存<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;活性、弱一致<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;性、非单射一<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;致性、单射一<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;致性、机密性、<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前向安全性</td>    <td>√</td>    <td>结合律、<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;交换律、<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DH 指数、<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xor、双线<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;性对等</td>    <td>√</td>    <td></td>  </tr>  <tr>    <td>UPPAAL</td>    <td>时间自动机</td>    <td>状态机</td>    <td>状态可达性</td>    <td></td>    <td></td>    <td>√</td>    <td>消息序列图和攻击图</td>  </tr>  <tr>    <td>SPIN</td>    <td>Promela</td>    <td>状态机</td>    <td>状态可达性</td>    <td></td>    <td></td>    <td>√</td>    <td>消息序列图和攻击图</td>  </tr></tbody></table><p>基于逻辑的形式化方法最典型的例子是BAN逻辑。它关注协议中可信参与者的信念，通过推导可信参与者在协议执行过程中能够正确执行协议的信念来分析协议。但是它仅能用来进行认证性上的验证，也不适用与太过复杂的方案，并且由于其语义过于简单不够完善，并不能全面地检查到问题。但是正因为它是最简单的逻辑证明方法，即便没有自动化和可视化的工具存在也足够方便使用，尽管它的局限性是众所周知的，而且许多其他基于逻辑的方法如 GNY、SVO被开发出来弥补它的缺点，但人们仍然喜欢选择它作为在许多工作中分析安全协议的形式化方法。</p><blockquote><p>GONG L, NEEDHAM R M, YAHALOM R. Reasoning about Belief in Cryptographic Protocols[C]//Proceedings of IEEE Symposium on Security and Privacy. 1990: 234-248.</p><p>Syverson P F, Van Oorschot P C. On unifying some cryptographic protocol logics[C]//Proceedings of 1994 IEEE Computer Society Symposium on Research in Security and Privacy. IEEE, 1994: 14-28.</p></blockquote><p>Paulson归纳法同样是基于逻辑的方法，但是它进行了无限状态空间方面的扩展，可以用来分析一些更加复杂的问题。不过因此它的证明过程也会显得更加复杂，虽然可以使用 Isabelle 定理证明器实现部分自动化，但是自动化的程度并不高，在处理复杂问题的时候依然会带来不小的开销。</p><blockquote><p>PAULSON L C. The inductive approach to verifying cryptographic protocols[J]. Journal of computer security, 1998, 6(1-2): 85-128.</p></blockquote><p>CSP 模型是比较早出现的用来描述并发系统中通过消息交换实现的交互通信实体行为的建模方式，它属于进程演算，但是它的自动化工具失败分歧细化（Failure Divergence Refinement，FDR）则采用了基于操作语义的状态搜索思想。不过虽然它能够实现高度的自动化但是却缺少能够直观体现结果的可视化功能。</p><blockquote><p>PROCESSES C S. Communicating sequential processes[J]. Communications of the Acm, 1978, 21(1): 666-677.</p></blockquote><p>应用PI演算也是进程演算的一种，它是PI演算的扩展，可以用直观的进程语法详细描述参与者（包括它们的交互）的行为。它可以用于无限数量的会话和无限的消息空间，不存在状态空间爆炸的问题，但是它的证明过程非常复杂，如果使用它进行人工地推导，将是一项非常耗时和费力的工作。所幸它可以使用基于 Dolve-Yao 模型的 ProVerif 工具实现对认证性和机密性的自动化分析。同时它还具有可视化的功能，当发现存在攻击时它可以生成相应的路径。</p><p>AVISPA 是一种高度自动化的验证工具，它提供了一种模块化的、表现力强的、基于角色的形式化语言高级协议规范语言（High Level Protocol Specification Language，HLPSL）来描述协议和它的安全特性，还整合了四种不同的分析终端来进行多种自动化分析。这个工具可以根据输入的模型看到模拟出来的消息序列图。如果分析的结果是不安全的，分析终端会输出相应的攻击轨迹，用户可以依据给出的反例找到协议的安全漏洞，并采用相应措施进行改进。</p><blockquote><p>ARMANDO A, BASIN D, BOICHUT Y, et al. The AVISPA tool for the automated validation of internet security protocols and applications[C]//Proceedings of International conference on computer aided verification. Springer, Berlin, Heidelberg, 2005: 281-285.</p></blockquote><p>UPPAAL 和 SPIN 是比较经典的采用模型检测方法的工具。UPPAAL 使用时间自动机作为输入。SPIN 用 Promela 语言将需要验证的系统描述成有限状态机，语法是基于进程的描述的，结构和C语言比较类似。它们都可以使用线性时序逻辑LTL对安全目标进行规约，然后通过对状态可达性的检查来分析安全目标是否可以实现，比如是否存在死锁等。然而正如本文之前所介绍的模型检测算法，这类工具最大的问题就在于状态空间爆炸，当所需要分析的系统太过于复杂导致需要进行搜索的状态空间太过于庞大时，往往不能得到很好的结果。</p><p>Scyther以及在它的基础上进行了改进的 Tamarin虽然同样采用了模型检测的思想，但是它们考虑了对状态进行逆向搜索的方法，根据需要得到的状态推导它之前的状态，能够排除掉无关的状态以此缩减状态空间，解决状态空间爆炸的问题。同时它们不仅能够实现 Dolve-Yao 模型下的检验，还可以进行 eCK 模型下的安全性分析。不过 Tamarin 还可以进行一些 DH、双线性对、Xor 等方面的运算，可以实现更加复杂的模型。</p><blockquote><p>CREMERS C J F. Scyther[J]. Proc Dimacs Workshop, 2011, 6(1): 324–337.</p><p>MEIER S, SCHMIDT B, CREMERS C, et al. The TAMARIN prover for the symbolic analysis of security protocols[C]//Proceedings of International Conference on Computer AidedVerification. Springer, Berlin, Heidelberg, 2013: 696-701.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 形式化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 形式化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献|sage</title>
      <link href="/2023/03/10/08-58-40/"/>
      <url>/2023/03/10/08-58-40/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>《Semi-Automated Protocol Disambiguation and Code Generation》</p><p>SIGCOMM ’21</p><p>2023.3.10</p></blockquote><p>文章提供了一个工具sage，可以发现RFC文档中存在歧义的地方，生成中间代码，从而生成代码，文章主要测试了ICMP和IGMP协议</p><p><img src="https://s2.loli.net/2023/03/09/aefWy1XSLhNpUJI.png" alt="主要流程图"></p><h2 id="语义解析">语义解析</h2><p>语义解析功能建立在工具CCG的基础上。</p><p>文章将RFC文档中的描述分为两类组件：</p><ul><li>概念型组件（ Conceptual components）：描述协议结构和行为，包括头字段的语义描述、发送者和接收者行为的规范、谁应该与谁通信、应该如何管理会话，以及应该如何构建协议实现。</li><li>语义型组件（ Syntactic components）：包括标图、表、状态机描述、通信图和算法描述</li></ul><p>sage分别有部分的解析能力，图中，绿色表示可以，橄榄色表示部分可以，其余都需要人为说明</p><p><img src="https://s2.loli.net/2023/03/09/V3IS5hJm1BwgGWC.png" alt="概念型组件与语义型组件"></p><p>还有一些难以解析的句子，是因为现阶段NLP的局限性</p><p><img src="https://s2.loli.net/2023/03/09/rOipBDeN4Hgsw9d.png" alt="语义解析局限"></p><p>工具CCG有一个词典（语料库），词典需要人为扩充，例如：</p><p><img src="https://s2.loli.net/2023/03/09/3ZVRufoHOn8Yzq7.png" alt="词典"></p><p>设置词典需要完成以下工作：</p><ul><li>指定特定领域的语法语义</li><li>提取RFC中的文本结构与非文本结构</li></ul><h2 id="消除歧义">消除歧义</h2><p>对于同一条自然语句，因为可能存在的歧义，sage会生成多条IR语句，为了消除歧义，sage定义了一个过滤器</p><ul><li>类：对于每个谓词，sage定义了一个或多个类型检查：操作谓词具有函数名称参数，赋值在左侧不能有常量，条件必须格式良好，以此类推</li><li>参数的顺序：sage会删除违反顺序的中间代码。</li><li>分配律：消除逗号</li><li>结合律：如果谓词是有关联的，那么它们的逻辑形式树将是同构的。sage使用一个标准的图同构算法来检测关联性。</li></ul><h2 id="测试">测试</h2><p><img src="https://s2.loli.net/2023/03/09/QbDIG1JY7Awv8F5.png" alt="测试1"></p><p><img src="https://s2.loli.net/2023/03/09/FSpmzGd7Yw3hvVC.png" alt="测试2"></p><p><img src="https://s2.loli.net/2023/03/09/nLC8vUws3SdPh6M.png" alt="测试3"></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文献 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust|Package,Crate,Module</title>
      <link href="/2023/02/22/23-08-23/"/>
      <url>/2023/02/22/23-08-23/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Rust代码组织">1. Rust代码组织</h2><p>代码组织可以决定哪些细节可以暴露，哪些细节是私有的，作用域内哪些名称有效。。。</p><p>模块系统：</p><ul><li><strong>package（包）</strong>：cargo特性，让你构建、测试、共享crate</li><li><strong>crate（单元包）</strong>：一个模块数，它可以产生一个library或可执行文件</li><li><strong>module（模块）、use</strong>：让你控制代码的组织、作用域、私有路径</li><li><strong>path（路径）</strong>：为struct、function或module等命名的方式</li></ul><p><img src="https://s2.loli.net/2023/02/23/DtTbpKoOa9cdYl8.png" alt="代码组织"></p><h2 id="1-1-package和crate">1.1 package和crate</h2><p>对于一个package，有以下规定：</p><ul><li>包含一个Cargo.toml，它描述了如何构建这些crates</li><li>最多包含一个library crate</li><li>可以包含任意数量的binary crate</li><li>至少包含一个crate（library或binary）</li></ul><p>crate有两种类型：binary和library，有一个crate root，是源代码文件，Rust编译器从这里开始，组成crate的根module</p><h2 id="1-2-cargo的惯例">1.2 cargo的惯例</h2><p>创建一个新的Rust项目，命名为<code>my-project</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo new my-project</span><br></pre></td></tr></table></figure><p>出现文件<code>src/main.rs</code>，该文件是binary crate的crate root，crate名与package名相同</p><p>若出现<code>src/lib.rs</code>（一般不会），该文件表示package包含一个library crate，其为library crate的crate root，crate名与package名相同</p><p>cargo把crate root文件交给rustc来构建library或binary</p><p>一个package可以同时包含<code>src/main.rs</code>和<code>src/lib.rs</code>，名称与package名相同。一个package可以同时有多个binary crate，文件必须放在<code>src/bin</code>中，每个文件是单独的binary crate</p><h2 id="1-3-定义module来控制作用域和私有性">1.3 定义module来控制作用域和私有性</h2><p>使用module有以下好处：</p><ul><li>在crate内，将代码进行分组</li><li>增加可读性，易于复hexo</li><li>控制项目（item）的私有性（public、private）</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>()&#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mod</span> serving</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>()&#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>()&#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Path路径">2. Path路径</h2><p>为了在Rust的模块中找到某个条目，需要使用<strong>路劲</strong>。</p><p>路径有两种形式：</p><ul><li><strong>绝对路径</strong>：从crate root开始，使用crate名或字面值crate</li><li><strong>相对路径</strong>：从当前模块开始，使用self，super或当前模块的标识符</li></ul><p>路径至少由一个标识符组成，标识符之间使用<code>::</code></p><p>以下例子来自文件<code>src/lib.rs</code>，即拥有lib crate root</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waiting</span>()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at</span> <span class="title function_ invoke__">restaurant</span>()</span><br><span class="line">&#123;</span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();<span class="comment">//绝对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();<span class="comment">//相对路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-Privacy-Boundary私有边界">2.1 Privacy Boundary私有边界</h3><p>模块不仅可以组织代码，还可以定义私有边界。如果想把<code>函数</code>或者<code>struct</code>等设为私有，可以将它放在某个模块中。定义规则：</p><ul><li>Rust中的所有条目（函数，方法，struct，enum，模块，常量）默认是私有的。</li><li>父级模块无法访问子模块中的私有条目。</li><li>子模块可以使用所有祖先条目。</li><li>同级条目可以互相访问。</li><li>使用<code>pub</code>关键字，将条目标记为公共。</li></ul><h3 id="2-2-super关键字">2.2 <code>super</code>关键字</h3><p>利用<code>super</code>关键字来访问父级模块路径中的内容，类似文件系统中的<code>..</code></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">server_order</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        super::<span class="title function_ invoke__">server_order</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-pub-struct和pub-enum">2.3 <code>pub struct</code>和<code>pub enum</code></h3><p>pub放在struct前，struct变为公共的，但是struct的字段还是默认私有的；struct的字段需要单独设置<code>pub</code>来变成共有的。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Breakfast</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast:<span class="type">String</span>,</span><br><span class="line">        seasonal_fruit:<span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Breakfast</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">summer</span>(toast:&amp;<span class="type">str</span>)<span class="punctuation">-&gt;</span>Breakfast</span><br><span class="line">        &#123;</span><br><span class="line">            Breakfast</span><br><span class="line">            &#123;</span><br><span class="line">                toast:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(toast),</span><br><span class="line">                seasonal_fruit:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">meal</span> = back_of_house::Breakfast::<span class="title function_ invoke__">summer</span>(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    meal.toast = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Wheat&quot;</span>);</span><br><span class="line">    meal.seasonal_fruit = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;blueberries&quot;</span>);<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pub放在enum前，<strong>enum是公共的，里面的变体也是公共的</strong>。</p><h2 id="3-use关键字">3. <code>use</code>关键字</h2><p>可以使用<code>use</code>关键字将路径导入作用域中，仍然遵循私有性规则。</p><p>相对路径、绝对路径都可以</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>()</span><br><span class="line">&#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-use的习惯用法">3.1 use的习惯用法</h3><ul><li><p>函数：针对函数一般引入其父模块，防止函数重名情况（父级）</p></li><li><p>struct，enum：指定完整路径（本身）</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;<span class="comment">//结构体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同名条目：父级，比如两个定义在不同模块的同名struct，要指定到父级</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f1</span>() <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f2</span>()<span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;&#125;</span><br></pre></td></tr></table></figure><p>也可以使用<code>as</code>关键字，为引入的路径指定本地的别名</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f2</span>()<span class="punctuation">-&gt;</span> IoResult&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-使用pub-use重新导入名称">3.2 使用<code>pub use</code>重新导入名称</h3><p>使用<code>use</code>将路径导入到作用域内后，该名称在此作用域内私有，<code>pub use</code>重导出，将条目引入作用域，该条目可以被外部代码引入到它们的作用域</p><h3 id="3-3-使用外部包（package）">3.3 使用外部包（package）</h3><p>cargo.toml添加依赖的包（package）</p><p>标准库（std）也被当做外部包，但是不需要修改cargo.toml添加，需要使用use将std中特定的条目引入当前作用域</p><h3 id="3-4-使用嵌套路径清理大量的use语句">3.4 使用嵌套路径清理大量的use语句</h3><p>可以使用嵌套路径在同一行内将同一个包或模块下的多个条目进行引入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">路径相同的部分::&#123;路径差异的部分&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std ::io;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">use::std::&#123;cmp::Ordering,io&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Writing;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>,Writing&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-通配符">3.5 通配符<code>*</code></h3><p>可以使用通配符<code>*</code>将某个模块下的所有条目引入，但是要谨慎使用。使用场景：</p><ul><li>测试，将所有被测试代码引入到tests模块</li><li>有时被用于预导入（prelude）模块</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust|所有权</title>
      <link href="/2023/02/17/21-41-06/"/>
      <url>/2023/02/17/21-41-06/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-什么是所有权">1.什么是所有权</h2><p><strong>所有权</strong>是Rust的核心特性，它让Rust不需要GC（垃圾收集器）就可以保证内存安全。</p><p>所有的程序在运行时都必须管理它们使用计算机内存的方式。有些语言（C#，java）有垃圾收集机制，在程序运行时，它们会不断地寻找不再使用的内存；有些语言（C、C++），程序员必须显式分配和释放内存。</p><p>Rust采用第三种方式：内存通过一个所有权管理系统管理，其中包含一组编译器在编译时检查的规则。当程序运行时，所有权特性不会减缓程序运行速度，因为Rust把内存管理相关工作提前到编译时。</p><h3 id="1-1-Stack-vs-Heap（栈内存vs堆内存）">1.1 Stack vs Heap（栈内存vs堆内存）</h3><p>对于Rust，一个值存储在栈上还是堆上，对语言行为和你要做的某些决定有更大的影响。</p><p>在代码运行时，stack和heap都是可用的内存，但是它们的结构不一样。</p><ul><li><strong>存储数据</strong></li></ul><p>stack后进先出，LIFO，添加数据叫压入栈，移除叫弹出栈。</p><p>所有存储在stack上的数据必须拥有已知的固定的大小，编译时大小未知的数据或运行时大小可能发生变化的数据必须存放在heap上。</p><p>当你把数据放入heap时，你会请求一定数量的空间；操作系统在heap里找到足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址。这个过程叫做在heap上进行分配，有时仅仅称为“分配”。</p><p>把值压在stack上就不叫分配。因为操作系统不需要寻找用来存储新数据的空间，那个位置永远在stack的顶端。把数据压在stack上要在heap上分配快的多。在heap上分配空间需要做更多的工作，操作系统首先要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配。</p><ul><li><strong>访问数据</strong></li></ul><p>访问heap上的数据要比访问stack上的数据慢，因为需要通过指针才能找到heap中的数据。如果指令在内存中跳转次数越少，那么速度越快。</p><p>stack上数据存放距离比较近，处理起来快一些。</p><p>heap上数据之间距离比较远，处理速度慢一些。此外在heap上分配大量空间也需要时间。</p><ul><li><strong>函数调用</strong></li></ul><p>当代码调用函数时，值被传入到函数（包括指向heap的指针）。函数本地的变量被压到stack上。函数结束后，这些值会从stack上弹出。</p><ul><li><strong>所有权存在的原因</strong></li></ul><p>管理heap数据是所有权存在的原因，这有助于解释它为什么会这样工作。</p><p>所有权解决的问题：</p><ol><li>跟踪代码的哪些部分正在使用heap的哪些数据；</li><li>最小化heap上的重复数据量；</li><li>清理heap上未使用的数据避免空间不足。</li></ol><p>这样就可以不经常去想stack和heap了。</p><h3 id="1-2-所有权规则">1.2 所有权规则</h3><ol><li>每个值都有一个变量，这个变量是这个值的所有者；</li><li>每个值同时只能有一个所有者；</li><li>当所有者超出作用域（scope）时，该值将被删除；</li></ol><ul><li><strong>变量作用域</strong></li></ul><p>scope就是程序中的一个项目的有效范围，这一点和其他语言都类似。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br><span class="line">&#123;   <span class="comment">//s不可用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;<span class="comment">//s可用</span></span><br><span class="line">    <span class="comment">//可以对s进行相关操作</span></span><br><span class="line">&#125;<span class="comment">//s作用域到此结束，s不再可用</span></span><br></pre></td></tr></table></figure><ul><li><strong>string类型</strong></li></ul><p>string存储在heap上，比基础标量数据类型更复杂。</p><p>在Rust中有字符串字面值，即程序里手写的字符串，它们是不变的，为了编译未知数量的文本，Rust采用string类型。</p><p>可以使用<code>from</code>函数从字符串字面值创建出string类型</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//::表示from是String类型下的函数</span></span><br></pre></td></tr></table></figure><p>这类字符串是可以被修改的。</p><h3 id="1-3-内存与分配">1.3 内存与分配</h3><p>字符串字面值，在编译时就知道它的内容了，其文本内容直接被硬编码到最终的可执行文件里。速度快、高效，是因为<strong>其不可变性</strong>。</p><p>String类型，为了支持可变性，需要在heap上分配内存来保存编译时未知的文本内容。当用完String后，需要某种方式将内存返回给操作系统，这一步，在拥有GC的语言中，GC会跟踪并清理不再使用的内存，没有GC就要我们识别内存何时不再使用，并调用代码将它返回。如果忘了，就浪费内存；如果提前做了，变量就变得非法；如果做了两次，就是double free bug，必须一次分配对应一次释放。</p><p>Rust采用了不同的方式：对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动交还给操作系统，走出作用域时调用<code>drop</code>函数。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;,world&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>变量和数据交互的方式：移动（move）</strong></li></ul><p>多个变量可以与同一个数据使用同一种独特的方式来交互，如</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure><p>整数是已知大小且固定大小的简单的值，这<strong>两个5</strong>被压到stack中。</p><p>如果类型是String，它由三个内容组成，一个指向存放字符串内容的内存的指针；一个长度<code>len</code>，就是存放字符串内容所需的字节数；一个容量<code>capacity</code>，值String从操作系统中总共获得内存的总字节数。具体如下。</p><p><img src="https://s2.loli.net/2023/02/08/78ZpduTIRVaLBPs.png" alt="String类型组成"></p><p>左边存放在stack，右边存放在heap。</p><p>当出现如下情况：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure><p>对于一般情况，String的数据会被复制一份。在stack上复制一份指针、长度、容量，并没有复制heap上的数据。当变量离开作用域时，Rust自动调用<code>drop</code>函数，释放heap内存，这会导致doouble free bug。</p><p><img src="https://s2.loli.net/2023/02/09/2LqxrDfckbat4TB.png" alt="s1赋值给s2"></p><p>为了保证内存安全，Rust没有尝试复制被分配的内存，Rust让s1失效，s1离开作用域时，Rust不需要释放任何东西。这里，我们用一个新的术语：移动（move）。</p><p>这里隐含一个<strong>设计原则</strong>：Rust不会自动创建数据的深拷贝，就运行时的性能而言，任何自动赋值的操作都是廉价的。</p><ul><li><strong>变量和数据交互的方式：克隆（clone）</strong></li></ul><p>如果真想实现深拷贝，就要用克隆，如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,s1,s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/09/FlpdirOARHcyt2P.png" alt="clone"></p><p>比较消耗资源。</p><ul><li><strong>stack上的数据：复制</strong></li></ul><p>Rust提供copy trait（可以理解为一个接口），可以用于像整数这样完全存放在stack上面的类型。如果一个类型实现了copy trait，那么旧的变量在赋值后仍然可用。但是一个类型或者该类型的一部分实现了drop trait，那么Rust不允许让他再去实现copy trait了。</p><p>一些拥有copy trait的类型：</p><p>所有整数类型，如<code>u32</code></p><p>bool</p><p>char</p><p>所有浮点类型，如<code>f64</code></p><p>任何需要分配内存或某种资源的都不是copy的</p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>岁末的信2022</title>
      <link href="/2022/12/31/19-01-34/"/>
      <url>/2022/12/31/19-01-34/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-tZONKggI" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1457549896" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>诚然，大多数人能吃饱，然后吃好，偶尔还能吃出点花样，不过是近十几年间的事情。</p><p>我的家乡没什么好吃的，我妈也做不出花样，但也不至于把我饿着。 夏天丝瓜，冬天青菜，总是霸占着餐桌。每天吃差不多的菜，四季轮回，这是生活常态。</p><p>小时候考了一百分，我妈就带我出去吃炸鸡腿，吃漂着辣油的豆腐脑，吃兰州牛肉拉面。对我来说，这就是天大的事情。</p><p>过年回外婆家，吃每家都会有的粉蒸肉、灌肠，吃鸡鸭鹅汤，吃两条谁都不敢动筷子的鱼。外婆外公不停给我夹菜，我的碗从没空过。我就偷偷把肉扔到地上，喂猫。我们过年，家里的老猫也胖了。</p><p>外婆总在操心做什么菜，对她来说，做饭就是头等大事。我从来不操心，因为桌子上总有我喜欢的菜，我从来没有体会过饥饿的滋味。在外婆家的桌子上，我深切地相信，日子是越来越好的。</p><p>后来，外公生了病。那年除夕，大舅家、小舅家，我们一家终于聚齐，那个桌子太大了，桌上的菜太多了。外公看着我们，只是喝点汤，再难吃下其他东西。我想，不怕，外公的病会好，菜也总在。</p><p>谁知一日轻佻，日后遗憾无尽。</p><p>上了高中，晚自习下课已经接近十一点。那段时间压力真大，回家没好气，不想说话。我妈就给我煮面，下小馄饨，切水果，看着我吃。她总问我明晚吃什么，仿佛明晚吃什么就是最重要的事。我吃完面条，两手一摆，随便吧，就回房间了。</p><p>倏忽上了大学，今年年初，我们因为疫情封在宿舍。两层食堂只有寥寥几个快餐窗口开放。我们拎着饭盒，跟着漫长的队伍打饭。每天趁着做核酸，我和QQ就会去超市排队，可是超市也是空的，货架上空空荡荡。第一次，我体会到对食物的焦虑。</p><p><img src="https://s2.loli.net/2022/12/31/SBQ9ixq7oPIMs3p.png" alt="老师的微信截图"></p><p>这年，我们大部分时间被封在学校。吃播几乎承载了我对美好食物的向往。我想起儿时的炸鸡腿，想起妈妈煮的面，想起外公外婆的年夜饭。</p><p>红尘颠倒，无情至此。</p><p>不想挨饿，但同时，一种具体而形而上的饿又困扰着我。</p><p>疫情年代，我和舍友在宿舍吃泡面，品尝饥饿。仿佛兜兜转转，一切重来。</p><p>吃饱吃好，永远是天大的事情。</p><p><img src="https://s2.loli.net/2022/11/11/AeFHqSL59dDZcNB.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家 </tag>
            
            <tag> 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈|新冠日记</title>
      <link href="/2022/12/25/14-44-19/"/>
      <url>/2022/12/25/14-44-19/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-QqGddBLc" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1300885683" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>简单记录我和QQ感染阶段的身心状况、用药情况和所思所感。</p><h2 id="我的日记">我的日记</h2><mark class="hl-label blue">12月21日前</mark> <p>回家之后，我时不时在宿舍群问问。大家好像都还坚挺。</p><img src="https://s2.loli.net/2022/12/25/wktzKHuch7iFMJy.jpg" alt="聊天截图" style="zoom:20%;" /><mark class="hl-label blue">17号</mark> 我妈感冒了，流鼻涕、嗓子疼，但没发烧，晚上她单独睡。<mark class="hl-label blue">18号</mark> 她的感冒症状依旧，但是依然没发烧，测了新冠唾液检测，阴性，又上班去了。<mark class="hl-label blue">20号中午</mark> ，我爸开始发烧，嗓子疼，他熬了姜汤，吃了一粒布洛芬就昏昏欲睡了。晚上测温，38.6℃，又吐了两次。当时感觉有点不妙，完全符合新冠症状。第二天早上他退烧，测了新冠唾液检测，竟然是阴性。现在想来，应该是唾液检测的误差太大，我爸我妈应该都感染了，只是我妈症状轻微。<img src="https://s2.loli.net/2022/12/25/wiORU542dCvhapf.jpg" alt="新冠唾液检测和抗原检测" style="zoom:30%;" /><p>图片里上面一包saliva test是新冠唾液检测，低头含在舌下就可以；下面一包是常见的鼻拭子抗原检测，以后还是多备点鼻拭子的吧，唾液检测一点也不准:(</p><mark class="hl-label blue">12月22日</mark> <p>一觉起来，我连打五六七八个喷嚏，喉咙有点不适，吃饭的时候我妈问我是不是熬夜玩手机了，眼睛好红。原来是熬夜玩手机玩的，我还以为阳了呢:)</p><p>晚上又开始连打喷嚏，我喝了包风寒感冒颗粒（现在才知道这药没用）就上床了。在床上好冷，浑身不住地颤抖，凌晨1:30开始发热，浑身滚烫，被子都掀了，测温38℃，吃了一粒布洛芬，等待药效起效的过程中，两腿酸痛，被子盖在身上有如千斤，翻身都很吃力。大概过了一个多小时，感觉布洛芬起了作用，慢慢入睡了。</p><mark class="hl-label blue">12月23日</mark> <p>早上头疼，鼻塞，腿酸痛，测了体温36.7摄氏度，退烧了。做了鼻拭子抗原检测，确定是阳了。</p><img src="https://s2.loli.net/2022/12/25/Xq5osOvgxFTiMwJ.jpg" alt="阳了" style="zoom: 25%;" /><p>折磨才刚刚开始。</p><p>起床之后腿是软的，腰也酸痛。动作稍微迅速一点就头晕。</p><p>晚上上床，和昨天一样冷得发抖，害怕复烧，我吃了一粒布洛芬。浑身难受，入睡困难，药效起了才舒服点。睡梦中又觉得时冷时热，梦里仿佛悲辛尝尽，过了一个世纪，醒来一看凌晨三点，就睡不着了。鼻塞，口干，用嘴呼吸，嘴巴干到起皮。</p><mark class="hl-label blue">12月24日</mark> <p>症状相比昨天差不多，鼻塞之后说话像丁真+丽丽。</p><p>看了COVID-19治疗手册，上面说轻症无需特殊治疗，根据需要对症下药。</p><blockquote><p>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzA3NjAzOTk5OQ==&amp;mid=2651929542&amp;idx=1&amp;sn=8b6c67ded4aa0df75eb0d99b99f3ad87&amp;chksm=8482c996b3f5408071453a4d9d01a337f911f4363ec55817d8de8d33abed05ee89a16826fd90&amp;mpshare=1&amp;scene=1&amp;srcid=1225ldlNQaULZuytG5xaJ25F&amp;sharer_sharetime=1671972490925&amp;sharer_shareid=fdd73e407b0d23d4b49cdd787d7ad251#rd">中国医科大学大学校友会公众号</a></p></blockquote><p>晚上在厕所，腿软，差点摔死。睡前吃了几粒连花清瘟胶囊，吃了感觉喉咙到胃很清凉，看来确实起到了缓解症状的效果。依然难以入眠，但是腿不那么疼了，切实感觉身体在好转。</p><mark class="hl-label blue">12月25日</mark> <p>今天起床感觉轻松一大截，还是鼻塞，测了抗原，竟然不是阳性了。</p><img src="https://s2.loli.net/2022/12/25/59DwALFPzQRpagq.jpg" alt="阴性" style="zoom:25%;" /><p>快点好起来吧。</p><h2 id="QQ的日记">QQ的日记</h2><div class="note info simple"><p>编者按：QQ比我提前几天感染新冠，她写了一篇名为《新冠我***》的日记，现以时间线的形式整理如下</p></div><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-20</p></div></div><div class='timeline-item-content'><p>开始嗓子不舒服</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-21</p></div></div><div class='timeline-item-content'><p>烧了一天，喉咙好疼，浑身没有力气，脑袋也好疼</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-22</p></div></div><div class='timeline-item-content'><p>烧退了，感觉好了很多，但还是有点疲惫，头还是疼，嗓子也疼</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-23</p></div></div><div class='timeline-item-content'><p>开始出现更多像感冒的症状，鼻塞，小咳嗽，有痰吐不出来。寒寒也中招了。我们竟然有相同的症状。鼻子水泄不通，难以入睡，头疼得厉害，不能用力，上厕所一用力头就疼，走路一振，头就疼。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-24</p></div></div><div class='timeline-item-content'><p>头疼占主流，晕乎乎的，鼻子还是不畅通，转移注意力，看了一集跑男。头真的太疼了。晚上上床整个人哆嗦，电热毯反反复复开了好多次，明天我一定要烧个热水袋！鼻子塞了可怎么睡得着觉啊！请问把鼻子割掉了可以呼吸吗，如果可以我愿意。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-25</p></div></div><div class='timeline-item-content'><p>凌晨真的想要撞墙，鼻子塞住了一个，能呼吸的那一个像充血一样，超级疼，不想呼吸了，如果可以不呼吸就好了。感觉自己呼吸都是错的。尝试用嘴呼吸，喉咙就干的快要裂了，嘴唇也毛毛躁躁红了一圈。用力擤鼻子，终于两个全塞住了。睡醒了嘴里好干，想要喝水，但爬不起来。十一点爬起来吃午饭，味同嚼蜡。米饭太硬了，每咽一口就像是要刀割一次喉咙。</p></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++|可变参数与void指针</title>
      <link href="/2022/11/30/11-31-29/"/>
      <url>/2022/11/30/11-31-29/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="可变参数">可变参数</h2><p>可变参数是指函数的参数的数据类型和数量都是不固定的。</p><p>例如<code>printf()</code>函数的参数就是可变的。这个函数的原型是：<code>int printf(const char *format,...)</code></p><h2 id="实现">实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> count, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello I am foo\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    va_list parameters;<span class="comment">//va_list变量</span></span><br><span class="line">    va_start(parameters,count);<span class="comment">//初始化,count是形参个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">void</span>* parameter = va_arg(parameters,<span class="type">void</span>*);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,(<span class="type">int</span>*)parameter);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_end(parameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>定义</strong></li></ul><p>一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</p><ul><li><code>va_list </code></li></ul><p>在函数定义中创建一个 <code>va_list </code>类型变量，该类型是在 <code>stdarg.h </code>头文件中定义的。它包含了参数信息，这种类型的对象也被称为<strong>参数指针</strong>。它包含了栈中至少一个参数的位置，可以使用它从一个可选参数到下一个。</p><ul><li><code> va_start</code></li></ul><p>使用 int 参数和<code> va_start</code> 宏来初始化 <code>va_list</code> 变量为一个参数列表。宏 <code>va_start</code> 是在<code>stdarg.h</code>头文件中定义的。宏 <code>va_start</code> 使用第一个可选参数的位置来初始化 <code>va_list</code> 参数指针。该宏的第二个参数必须是该函数最后一个有名称参数的名称。必须先调用该宏，才可以开始使用可选参数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_start</span><span class="params">(va_list argptr, lastparam)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>va_arg</code></li></ul><p>使用 <code>va_arg</code> 宏和<code>va_list</code>变量来访问参数列表中的每个项。展开宏 <code>va_arg</code> 会得到当前参数指针所引用的可选参数，也会将参数指针移动到列表中的下一个参数。宏 <code>va_arg</code> 的第二个参数是刚刚被读入的参数的类型。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="title function_">va_arg</span><span class="params">(va_list argptr, type)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>va_end</code></li></ul><p>使用宏 <code>va_end</code> 来清理赋予 <code>va_list</code> 变量的内存。当不再需要使用参数指针时，必须调用宏 <code>va_end</code>。如果想使用宏 <code>va_start</code> 或者宏 <code>va_copy</code> 来重新初始化一个之前用过的参数指针，也必须先调用宏 <code>va_end</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_end</span><span class="params">(va_list argptr)</span>;</span><br></pre></td></tr></table></figure><h2 id="void">void*</h2><p><code>void</code>被翻译为“无类型”，相应的<code>void*</code>为“无类型指针”。</p><p><code>void*</code>指针变量可以指向任意变量的内存空间，任意类型指针变量都可以转换为<code>void*</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>* p = &amp;num;</span><br><span class="line"><span class="type">int</span>* p_num = &amp;num;</span><br><span class="line"><span class="type">void</span>* p1 = p_num;</span><br></pre></td></tr></table></figure><p>对于<code>void*</code>指针变量，不要解除引用操作，如果想通过指针变量p获取num的值，需要强制类型转换</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p_num = (<span class="type">int</span>*)p;</span><br><span class="line">cout&lt;&lt; *p &lt;&lt;endl;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈|人生的必经之路？</title>
      <link href="/2022/11/27/17-51-32/"/>
      <url>/2022/11/27/17-51-32/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这周天，我担任了2020级网信院发展对象谈话面试官，与其他四位同志共同面试了25位积极分子。我不希望把这次活动看成“面试”，这只是一个有时间规定的谈话活动。我也不喜欢打分，打分是出于一些不得不遵守的规定，我知道，冰冷的分数不能代表我们思想的火花。从学生的角度来说，我们都是平等的。</p><p>与诸君交流，收获良多，简单记录如下。也想借此契机谈谈向组织靠拢的过程中、在我们成长的关键时期，可以警惕，可以反思的思维倾向。</p><h2 id="陈言套语的套用-anger">陈言套语的套用:anger:</h2><p>许多同学都喜欢说套话、说官话。我们生活在这种环境中，这是正常的，但也是不对的。拿我自己举例，高中写作文没题目，就写在时代中坚守，在传统中创新。大一大二写思想汇报，想不到词就写“巩固了、夯实了、扩大了，武装头脑、指导实践、深入贯彻”。现在读论文，积累黑话，没有思路就写“显然可以得知”，缺乏转折就写“有意思的是”，用了excel就写“通过推演运算，加上广泛的数字化可视数据”。</p><p>有错吗，当然不。甚至有些人连套话都说不出来，至少面试的大多数同学都愿意背一些。但是扪心自问，孱弱吗，苍白吗，值得深入挖掘意义吗。我们的时代在发展，语境也会不同。“陈言务去”，希望我们都能有自己的想法，在不同的时代，找到属于自己的阐释空间。</p><h2 id="空而无物的叙述-exclamation">空而无物的叙述:exclamation:</h2><p>或许是高中写作思维的桎梏，一些同学的叙述往往太空泛。比如“对xx有了更深刻的认识”，那么“认识”是什么，讲不清，意义不明。比如说自己从小被组织的事业感染引领，感恩自己生活在好时代，需要砥砺前行，那么是什么事业，怎样被感染，怎样做的，说不出所以然。</p><p>空泛的言语透露空洞的思想。看不出对周围事物的关切，也没现实的思考。单靠情绪与形容词来组织语言，是一种“讨巧”的方法，反而会弄巧成拙。谈话短短五分钟，从身边切入，从小事入手。能够给人感动的，不是“伟大光荣正确”，而是雪后的阳光，是同志温暖的握手，是书院记得我们所有人的生日。</p><h2 id="真诚才是必杀技-heart">真诚才是必杀技:heart:</h2><p>短短五分钟的谈话，要给几个完全不认识的人剖析内心，袒露思想，太难了。除非有过系统化的培训，不然临时背诵、编篡、组织都容易露怯。最简单也是最好的方法，是真诚。因为说谎话太难了，需要天赋。</p><p>给我印象最深的同学来自新疆，ta讲述了父亲守边的故事。故事里有一米厚的大雪，有风雪中的牛羊。ta又谈到家乡的疫情，提到对政策毫无保留的支持，同时也谈到家乡人民的善良、勇敢与无奈。我相信ta的讲述都是亲身经历的，是真切的。ta没有把话“说得很漂亮”，但是至少，言之有物、信源准确、辩证开放。</p><h2 id="总结">总结</h2><p>想起一位同学说，入党是人生必须走的路。由此可见，思维深处，我们也许对某些高大上的概念，对我们的党，形成了一个固化的认知结构。人生有很多路，它们通向真理、勇敢、善良、自由，但是没有路是“必须的”，只要你真心向往，路都是殊途同归的。</p><p>这些既是我看到的问题，也是我对自己的要求。虽然我也没有完全做到，但我依然为此砥砺。</p><p>共勉。</p><img src="https://s2.loli.net/2022/11/29/M3BvAbtp25Yqk1L.png" alt="image-20221129174934576" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLVM|LLVM入门的入门</title>
      <link href="/2022/11/16/17-50-25/"/>
      <url>/2022/11/16/17-50-25/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><a href="https://llvm.org/docs/ProgrammersManual.html#introduction">https://llvm.org/docs/ProgrammersManual.html#introduction</a></p><p><a href="https://llvm.org/docs/LangRef.html">https://llvm.org/docs/LangRef.html</a></p><p>2022年11月16日</p><p>:heart:</p></blockquote><h2 id="0-前言">0.前言</h2><p>对程序进行分析，不管是静态还是动态，都需要插桩。从LLVM入手插桩很方便，师兄花了很长时间研究，实验室只有他孤军奋战、苦苦求索，备受孤独与迷茫的双重煎熬。导师坦言担心他的精神状态。</p><p>之后，师兄每周给我们开小灶，进行鞭挞:cry:</p><p>之所以称为入门的入门，是因为我还没真正入门:smile:</p><p>我还不能系统地写明LLVM的种种，本文只对其进行简要介绍，引导志同道合的朋友。同时，在前面的引用奉上官方文档，希望共同进步。</p><h2 id="1-LLVM简介">1.LLVM简介</h2><p>编译原理把编译过程分为前后端：</p><ul><li>前端把源代码翻译成中间表示（IR）</li><li>后端把IR编译成目标平台的机器码。当然IR也可以直接给解释器解释执行。</li></ul><p>经典的编译器如<code>gcc</code>在设计上提供一条龙服务，即我们不需要知道它的IR是什么，它也不提供接口给我们来操作其IR。这种做法有好有坏。好处是从前端到后端，这些编译器的代码强耦合，可以在内部做任何想做的优化。坏处是，每当一个新平台出现，这些编译器都要各自为政实现一个从IR到新平台的后端。如果出现一种新语言，那么可能就需要实现一个新的编译器，重新设计一个新的IR。如果有M种新语言，N种新平台，那么最坏的情况下，需要实现M*N个前后端，比较低效。</p><p>为此，我们希望有一种共用的IR，每当有一种新语言，就添加其到IR的前端，每当有一个新平台，就添加其到IR的后端。如果有M种新语言，N种新平台，最优情况下我们只需要实现M+N个前后端。</p><p>LLVM就是这样一个项目。LLVM的核心设计了一个叫LLVM IR的中间表示，并以库的方式提供一系列接口，提供各种功能。</p><h2 id="2-Clang简介">2.Clang简介</h2><p>Clang是一个基于LLVM的编译器驱动，它提供把C/C++/OC等语言翻译成LLVM IR的前端，并使用LLVM的库实现LLVM IR到目标平台的后端。</p><p>叫编译器驱动是因为使用<code>clang main.c -o main</code>（Clang兼容gcc语法）的时候，Clang帮我们“驱动”C语言预处理器，C语言前端，LLVM后端，链接器等等。其实GUN gcc也是编译器驱动。为了方便，我们习惯称为编译器。</p><p>一般我读Clang为/see-lang/，但是其实很多人读/klang/，哈哈。</p><h2 id="3-LLVM-IR-Intermediate-Representation">3.LLVM IR(Intermediate Representation)</h2><p>LLVM的中间表⽰，本质上⼀种与源编程语⾔和⽬标机器架构⽆关的通用中间表⽰</p><p>LLVM IR是⼀种类似于RISC的低级虚拟指令集</p><p>LLVM是使⽤简单类型系统的强类型(例如， <code>i32</code>是⼀个32位整数， <code>i32*</code>是指向32位</p><p>整数的指针)</p><p>LLVM IR 不使用一组固定的命名寄存器,它使⽤⼀个名为%字符的无限临时集合</p><p>LLVM IR代被设计成三种不同的形式：内存编译器IR，磁盘⼆进制<code>.bc</code> 表⽰(适合于即时编</p><p>译器的快速加载)，可读的汇编语⾔<code>.ll</code></p><h3 id="3-1-IR结构">3.1 IR结构</h3><p>Module（模块）是⼀份LLVM IR的顶层容器，对应于编译前端的每个翻译单元（TranslationUnit）。每个模块由⽬标机器信息、全局符号（全局变量和函数）及元信息组成。</p><p>Function（函数）就是编程语⾔中的函数，包括函数签名和若干个基本块，函数内的第⼀个基本块叫做入口基本块。</p><p>BasicBlock（基本块）是⼀组顺序执⾏的指令集合，只有<strong>⼀个入口和⼀个出口</strong>，非头尾指令执行时不会违背顺序跳转到其他指令上去。每个基本块最后⼀条指令⼀般是跳转指令（跳转到其它基本块上去），函数内最后⼀个基本块的最后条指令是函数返回指令。</p><p>Instruction（指令）是LLVM IR中的最小可执行单位，每⼀条指令都单占一行</p><p>一个Module中可以有n个Function，Function内可以有n个BasicBlock，BasicBlock是单进单出的n条Instruction序列。</p><img src="https://s2.loli.net/2022/11/30/wzMOfhPG8V5Xetq.png" style="zoom: 50%;" /><h3 id="3-2-IR格式转换">3.2 IR格式转换</h3><p><img src="https://s2.loli.net/2022/11/30/HLeRD2a7Un95vlC.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL的安装与测试</title>
      <link href="/2022/11/11/21-44-45/"/>
      <url>/2022/11/11/21-44-45/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1-AFL的安装">1.AFL的安装</h3><p>先安装gcc，我的虚拟机还没装。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//先安装gcc </span><br><span class="line">sudo apt-get install gcc</span><br><span class="line">//查看gcc版本看是否安装成功</span><br><span class="line">gcc -v</span><br></pre></td></tr></table></figure><p>之后发现还需要clang和llvm，要啥装啥吧。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install clang</span><br><span class="line">sudo apt-get install llvm</span><br></pre></td></tr></table></figure><p>下载AFL，开始愉快地安装，很快啊。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/google/AFL</span><br><span class="line">cd AFL</span><br><span class="line">make</span><br><span class="line">//如果显示make command not found 运行下面两条命令</span><br><span class="line">apt install make</span><br><span class="line">apt upgrade</span><br></pre></td></tr></table></figure><h3 id="2-AFL测试">2.AFL测试</h3><p>我根据网上的教程，直接输入<code>afl -fuzz</code> 显示找不到afl命令，那就直接测试一个具体的文件试试。</p><p>创建一个testfile文件夹，然后在该文件夹下创建测试文件afl_test.c，内容如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vuln</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>敲命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">afl-gcc -g -o afl_test test.c</span><br></pre></td></tr></table></figure><p>显示如下</p><p><img src="https://s2.loli.net/2022/11/11/GVoN5SELYvACfTd.png" alt="image-20221013210725121"></p><p>于是我又试了命令<code>apt install afl</code></p><p>重新尝试，</p><p><img src="https://s2.loli.net/2022/11/11/ykFLXg2E7SjZM9b.png" alt="image-20221013211737042"></p><p>接着建立fuzz_in文件夹，创建输入文件testcase，输入文件中写几个简单单词，fuzzing时会产生简单变异。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir fuzz_in</span><br><span class="line">echo &quot;hello&quot; &gt; fuzz_in/testcase</span><br></pre></td></tr></table></figure><p>进行fuzz，结果如图。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i fuzz_in -o output ./afl_test</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/11/4hflSNvwZgWYAFs.png" alt="image-20221013212507389"></p><h3 id="3-基于编译器的目标程序插桩">3.基于编译器的目标程序插桩</h3><h4 id="3-1下载目标程序集-coreutils-9-1-tar-gz">3.1下载目标程序集(coreutils-9.1.tar.gz)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://ftp.gnu.org/gnu/coreutils/coreutils-9.1.tar.gz</span><br><span class="line">tar -zxvf coreutils-9.1.tar.gz</span><br></pre></td></tr></table></figure><h4 id="3-2使用afl-gcc，生成coreutils的每个二进制程序">3.2使用afl-gcc，生成coreutils的每个二进制程序</h4><ul><li><p>查看 coreutils 的 configure 选项，指定 <code>cc=afl-gcc</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure CC=afl-gcc</span><br></pre></td></tr></table></figure><p>这一步用来生成Makefile，为了下一步编译做准备，可以通过在configure后面加参数进行控制。</p><p>可以通过 <code>./configure --help</code>查看帮助</p><p><strong>问题</strong></p><p><img src="https://s2.loli.net/2022/11/11/qgW81k6nl3UQ9vL.png" alt="image-20221014112413555"></p><p>通过百度找到<a href="https://blog.csdn.net/tx422/article/details/78593860?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-78593860-blog-115320610.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-78593860-blog-115320610.pc_relevant_aa&amp;utm_relevant_index=2">解决方案</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export FORCE_UNSAFE_CONFIGURE=1</span><br></pre></td></tr></table></figure><ul><li></li></ul></li><li><p>生成 coreutils 二进制程序集。make 出来的每一个插桩后二进制均在 coreutils-9.1/src 目录下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3为-coreutils-的特定程序确定输入种子">3.3为 coreutils 的特定程序确定输入种子</h4><p>coreutils 包含很多二进制程序，任选其中程序进行 fuzzing。</p><p>构造输入种子列表，存放于coreutils-9.1/src/input 目录下，构造方法可以选择：</p><ul><li><p>学习 coreutils <a href="https://www.gnu.org/software/coreutils/manual/coreutils.html">文档</a>中这 3 个程序的命令行选项，用这些命令行选项构建</p></li><li><p>直接用随机构造的任意字符串作为输入种子。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir input</span><br><span class="line">mkdir output</span><br><span class="line">cp ../../AFL/dictionaries/* ./input # 将字典拷贝到input目录下</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-4在coreutils-9-1-src-目录下，使用-afl-fuzz-i-input-o-output-程序名-进行fuzzing，一段时间后终止fuzzing-并在-coreutils-9-1-src-output-目录下查看测试结果。">3.4在coreutils-9.1/src 目录下，使用 <code>afl-fuzz -i input -o output ./[程序名] @@</code>进行fuzzing，一段时间后终止fuzzing 并在 <code>coreutils-9.1/src/output</code> 目录下查看测试结果。</h4><p><img src="https://s2.loli.net/2022/11/11/n8hKbgBkUoQXiN4.png" alt="image-20221014113912837"></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献|eTPL</title>
      <link href="/2022/10/27/22-01-46/"/>
      <url>/2022/10/27/22-01-46/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1-摘要">1.摘要</h3><p>为了弥补TPL（TLS Presentation Language），文章提出了增强的TPL语言（eTPL）。文章首先定义了一个二进制数据解析的生成模型。基于此，文章为TPL提供了一组可以捕获重要信息的语言结构。如果没有这些结构，TPL中的重要信息只能由人工“手动”获取。最后，文章提出两种软件工具：gmt-c++和etpl-tool。</p><h3 id="2-创新点">2.创新点</h3><h4 id="2-1通用解析模型">2.1通用解析模型</h4><p>受TLS固有的解析范式启发，开发此通用模型来解析TLS的复杂的二进制编码。</p><blockquote><p>解析范式见tls不同版本的规范文档。例如<a href="https://datatracker.ietf.org/doc/html/rfc5246">RFC5246</a></p></blockquote><h5 id="2-1-1专用名词与概念解释">2.1.1专用名词与概念解释</h5><ul><li><strong>解析（parsing）</strong>：指二进制数据流转换成一种结构（树）表示的过程，在输入流解析时不能有任何跳变。</li><li><strong>序列化（serialization）</strong>：相反的过程，从树表示转换为二进制流，通过深度优先的树遍历。</li><li><strong>类型（type）</strong>：类型是解析数据的方法。类型可以是“原子的”，没有解析相关的子结构（例如整型或者不透明的原始数据an opaque blob of raw data）；类型也可以是复合的（类似结构体，例如由不同字段组成的网络数据包）。</li><li><strong>字段（filed）</strong>：<em>类型</em>的实例，通常由复合的<em>类型</em>定义。</li><li><strong>解析器（parser/dissector）</strong>:<em>类型</em>解析方法的实现。复合<em>类型</em>的解析器将输入数据流交给子解析器。如果字段依赖于前面字段的解析结果，则相应的子解析器将被实时实例化。要解析的输入流可以以任意碎片的形式提供，即流中的中间不连续性不影响解析结果。</li><li><strong>长度（length）</strong>：<em>解析器</em>在某个时间点上消耗的数据量。</li><li><strong>大小（size）</strong>：<em>解析器</em>或者<em>类型</em>的目标值（可选）。</li><li><strong>溢出（overflow situation）</strong>：所有解析器的子解析器已经满了，但是还有数据流要输入。</li><li><strong>underflow situation</strong>：父解析器已满，但是不是所有的子解析器都满了。</li></ul><p><img src="https://s2.loli.net/2022/11/11/w2dUAN9ljeKE71L.png" alt="image-20221028112948242"></p><p><img src="https://s2.loli.net/2022/11/11/XhQ7g3pMJLWO4v8.png" alt="image-20221028114126692"></p><h5 id="2-1-2通用消息树（Generic-Message-Trees）">2.1.2通用消息树（Generic Message Trees）</h5><p>GMT是由<em>解析器</em>实现的消息的树形表示。</p><p>叶子节点与不能再解析的“元消息”有关。</p><p>除了静态和不可变的<em>类型</em>，GMT还拥有动态<em>类型</em>组件，可以由GMT在运行时解析的具体数据来确定。（select/case）</p><p>此外，GMT节点还有可扩展的元信息。</p><p><img src="https://s2.loli.net/2022/11/11/NGb81umdtU5OTsP.png" alt=""></p><h5 id="2-1-3-TPL-eTPL">2.1.3 TPL &amp; eTPL</h5><p>TPL的定义不明确，可读性差。于是提出了加强型TPL（etpl），部分增强功能如下：</p><ul><li><em><em><em>类型</em>和</em>字段</em>的显示大小（Explicit size of types and fields）**：定义类型与字段的大小。</li><li><strong><em>类型</em>参数化（Type parametrization）</strong>：允许类型具有参数，并定义一个语言构造来在实例化类型时设置这些参数。整数类型的可接受数值限制（最小值/最大值）。</li><li><strong>动态解析上下文（Dynamic parsing context）</strong>：引入了允许使用GMT提供的动态解析上下文的语言结构。解析上下文由嵌入了一个解析器的（部分增长的）GMT给出。具体元素（即GMT节点或与GMT节点相关联的元信息）使用相对于解析器在GMT中的位置的路径来引用。</li></ul><p><img src="https://s2.loli.net/2022/11/11/LA8pZdobVCaSUHX.png" alt=""></p><h3 id="3-复现">3.复现</h3><h4 id="3-1-gmt-cpp">3.1 <a href="https://github.com/phantax/gmt-cpp">gmt-cpp</a></h4><p>通用消息树（GMT）的c++实现。</p><ol><li><p>下载库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/phantax/gmt-cpp.git</span><br></pre></td></tr></table></figure></li><li><p>下载 bitbuffers-cpp 库并创建软链接至gmt-cpp的目录。这里建议用绝对路径，否则会出现“链接层数过多”的问题。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/phantax/bitbuffers-cpp.git</span><br><span class="line">ln -s home/mkh/bitbuffers-cpp home/mkh/gmt-cpp/bitbuffers-cpp</span><br></pre></td></tr></table></figure></li><li><p>下载propertynode-cpp 库并创建软链接；与2同理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/phantax/propertynode-cpp.git</span><br><span class="line">ln -s home/mkh/propertynode-cpp home/mkh/gmt-cpp/propertynode-cpp</span><br></pre></td></tr></table></figure></li><li><p>build</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd gmt-cpp</span><br><span class="line">make deps</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li></ol><p>gmt-cpp是一个在C++中实现gmt概念的库。为了使用这些代码，需要一个针对gmt-cpp链接的应用程序。<br>test/子目录中有一个测试应用程序，可以将其用作起点。为了构建和运行测试应用程序（在构建gmt-cpp库之后），键入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make test</span><br><span class="line">./test/test</span><br></pre></td></tr></table></figure><p><strong>test.cpp源代码如下</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InternalNode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tls-with1.3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hex representation of a TLS ClientHello message generated with OpenSSL.</span></span><br><span class="line">    string hex = <span class="string">&quot;0x&quot;</span></span><br><span class="line">            <span class="string">&quot;160301012c01000128030340c70e243001b96d8c63687738696432d3e6f949&quot;</span></span><br><span class="line"><span class="string">&quot;107aabad8450cdffd6a266e4000092c030c02cc028c024c014c00a00a3009f&quot;</span></span><br><span class="line"><span class="string">&quot;006b006a0039003800880087c032c02ec02ac026c00fc005009d003d003500&quot;</span></span><br><span class="line"><span class="string">&quot;84c02fc02bc027c023c013c00900a2009e0067004000330032009a00990045&quot;</span></span><br><span class="line"><span class="string">&quot;0044c031c02dc029c025c00ec004009c003c002f00960041c011c007c00cc0&quot;</span></span><br><span class="line"><span class="string">&quot;0200050004c012c00800160013c00dc003000a001500120009001400110008&quot;</span></span><br><span class="line"><span class="string">&quot;0006000300ff0100006d000b000403000102000a00340032000e000d001900&quot;</span></span><br><span class="line"><span class="string">&quot;0b000c00180009000a00160017000800060007001400150004000500120013&quot;</span></span><br><span class="line"><span class="string">&quot;000100020003000f0010001100230000000d0020001e060106020603050105&quot;</span></span><br><span class="line"><span class="string">&quot;020503040104020403030103020303020102020203000f000101&quot;</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">VectorBuffer buf;</span><br><span class="line"></span><br><span class="line">    buf.<span class="built_in">appendFromString</span>(hex);</span><br><span class="line">    </span><br><span class="line">    TVector_MainType node;</span><br><span class="line"></span><br><span class="line">    node.<span class="built_in">dissector</span>().<span class="built_in">dissectFromBuffer</span>(buf);</span><br><span class="line"></span><br><span class="line">    node.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    DataUnit* testnode = node.<span class="built_in">getByPath</span>(<span class="string">&quot;**/ClientHello_extensions%/_V/~2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~-2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~-2&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~-1&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~0&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~1&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~2&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~r-2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~r-2&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~r-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~r-1&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~r0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~r0&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~r1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~r1&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~r2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    testnode-&gt;<span class="built_in">getSibling</span>(<span class="string">&quot;~r2&quot;</span>)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://s2.loli.net/2022/10/31/CnNcvodT9kLyx8D.png" alt="image-20221027155629256"></p><h4 id="3-2-etpl-tool">3.2 etpl-tool</h4><p>用etpl作为派生解析例程的描述语言。</p><p>we brieflfly presented a software tool that automatically generates C++ message parsers from eTPL defifinitions.</p><p><img src="https://s2.loli.net/2022/10/31/J9AtB4znbdcClN5.png" alt="image-20221031145119569"></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> 文献 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊测试小总结</title>
      <link href="/2022/10/20/21-52-50/"/>
      <url>/2022/10/20/21-52-50/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>模糊测试基本流程：预处理、输入数据构造、输入选择、评估、结果分析。</p><p>根据模糊测试对程序内部信息分析的程度,现代的模糊测试方法可以划分为３类:黑盒模糊测试、灰盒模糊测试和白盒模糊测试。</p><p>AFL是覆盖率为导向的模糊测试工具，通过插桩的方法,采集输入数据对应的<strong>边覆盖率</strong>,作为模糊测试种子选取的衡量指标．通过使用进化算法以及精心构造的突变策略。</p><p>通过对源码进行重新编译时进行插桩（简称编译时插桩）的方式利用自动产生测试用例来探索二进制程序内部新的执行路径。AFL也支持直接对没有源码的二进制程序进行测试，但需要QEMU的支持。它可以：</p><ul><li>其可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。</li><li>由于需要在相关代码处插桩，因此AFL主要用于对开源软件进行测试。</li><li>配合QEMU等工具，也可对闭源二进制代码进行fuzzing，但执行效率会受到影响。</li></ul><h3 id="1-预处理">1.预处理</h3><p>工作:搜集目标相关信息并制定模糊测试的策略, 为监控目标在测试中的运行状态做必要的准备．通常依赖于<strong>插桩、符号执行以及污点分析</strong>这类程序分析技术</p><p>搜集目标相关信息,比如目标的输入数据格式、目标的内部结构,并为监控测试中目标的状态变化做必要的准备．</p><p>该环节面临的挑战是:使用什么程序分析技术,以及模糊测试究竟需要对目标内部信息有多详细的了解。</p><h4 id="1-1插桩">1.1插桩</h4><p>插桩技术通向目标代码中合适的位置添加预设好的代码。获得程序的静态或动态执行信息，比如程序的抽象语法树，覆盖率以及函数内变量取值等。</p><p><strong>动态插桩</strong></p><p>是指在运行过程中对代码插桩。比如利用QEMU等模拟技术，可以获得程序运行时的信息，缺点是资源开销大。</p><p><strong>静态插桩</strong></p><p>通过gcc编译器在汇编语言上插桩，LLVM在生成中间语言LLVMIR(low level virtual machine intermediate representation)上插桩。优点是节省时间、速度快，缺点是依赖于程序源码。</p><h4 id="1-2符号执行">1.2符号执行</h4><p>将程序行为归结为逻辑领域的推理，通过构建一个表示程序执行的逻辑公式，可以同时推断一个程序在不同输入上的行为。该方法可以使模糊测试获得较好的覆盖率，并可以深入到程序深处。</p><p><strong>静态程序执行</strong></p><p>容易陷入路径爆炸中，用得不多。</p><p><strong>动态符号执行</strong></p><p>动态符号执行通过对程序进行实际执行与符号化执行，维护程序的实际执行和符号化状态，<strong>通过将难以求解的约束替换为实际值，缓解了符号执行的问题</strong>，并按照<strong>深度优先</strong>的搜索策略对目标程序进行了探索。（有点抽象）</p><p>存在的问题：</p><ul><li>路径爆炸问题依然存在，解决办法可以通过启发式算法，选择比较重要的路径探索。</li><li>虽然动态符号执行使用实际值替换的方法，解决了一部分静态符号执行无法绕过的约束，但是也丢失了一部分路径，造成探索结果是不完整的。</li><li>所有符号执行技术都受限于约束求解方法的能力。</li></ul><h4 id="1-3污点分析">1.3污点分析</h4><p>观察程序中，哪些数据收到了预先准备好的污染源的污染，目的是跟踪污染源和汇聚点之间的信息流。</p><p><strong>静态污点分析</strong></p><p>通过对程序静态分析,获得程序控制流图、抽象语法树等信息, 依据数据流以及依赖关系进行污点分析。</p><p><strong>动态污点分析</strong></p><p>动态污点分析检测的可信度更高,但是检测结果是否全面, 取决于动态污点分析对程序的覆盖情况,而且动态污点分析会消耗更多的资源; 静态污点分析又会和符号执行一样,可能会陷入到路径爆炸中,而简化后的静态污点分析又存在着严重的过度污染问题。</p><h3 id="2-输入构造">2.输入构造</h3><p><strong>种子获取、种子筛选、种子突变</strong></p><p>具体的挑战是如何在尽量满足语法语义检查的情况下，短时间内生成大量的输入，用以对目标做全面而深入的分析。</p><p>首先得到一个数据S，然后S按照一定的策略进行一定次数的变异，获得大量新数据I，最后将I输入到被测试对象中进行测试，其中数据S被称为种子seed，I是测试实际使用的输入数据。</p><h3 id="3-评估">3.评估</h3><p>现阶段的研究聚焦于模糊测试器在2个指标上的表现：<strong>覆盖率</strong>和<strong>暴露漏洞平均时间</strong>。</p><p><strong>覆盖率</strong></p><p>软件测试中的一个衡量指标,指的是在测试过程中,对象被覆盖到的数目占总数的比例． 通常而言,高覆盖率更可能发现更多的隐藏漏洞,众多研究因此集中在覆盖率提升上。</p><ul><li><p>AFL 使用上下文无关的<strong>边覆盖率</strong>作为评估指标。</p></li><li><p>Angora 使用上下文敏感的分支覆盖率。</p></li><li><p>VUzzer 使用了块覆盖率替代边覆盖率作为覆盖率评估的对象。</p></li></ul><p><strong>暴露漏洞平均时间</strong></p><p>在 与 基 准 模 糊 工 具AFL的对比实验中，AFLGo复现单个漏洞的时间远比AFL少，这证明了该评估指标的有效性。此后Hawakeye同样使用了这一指标来证明其性能。Parmesan 在通过sanitizer来发现潜在漏洞的研究工作中，也是用暴露漏洞平均时间作为评估指 标同Angora等定向灰盒模糊工具进行比较。</p><h3 id="4-结果分析">4.结果分析</h3><p>发生在模糊测试之后，主要目的是对于模糊测试的输出信息进行分析和处理。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker的学习</title>
      <link href="/2022/10/18/21-49-12/"/>
      <url>/2022/10/18/21-49-12/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1-概述">1.概述</h3><p>docker是什么？按我的理解类似一个轻量的虚拟机，将计算机资源虚拟化，这里的计算机资源，可以暂时理解成计算能力和数据存储。虚拟化的好处在于，打破资源不可分割的障碍，可以更好地配置。我们可以在docker里面打包网站、程序甚至是它们需要的系统环境，独立打包、互不干扰、方便快捷。</p><p><strong>docker启动流程</strong></p><p><img src="https://s2.loli.net/2022/11/12/JM8zYyXE3wBbmSC.png" alt="img"></p><p><strong>docker命令概览</strong></p><p><img src="F:/%E5%90%84%E7%A7%8D%E8%AF%BE/fuzz/%E7%AC%94%E8%AE%B0%E6%B1%87%E6%8A%A5/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55Sf5L-h5oqA5pyv,size_20,color_FFFFFF,t_70,g_se,x_16%23pic_center.png" alt="img"></p><h3 id="2-启动docker">2.启动docker</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker   # 启动Docker</span><br><span class="line">systemctl enable docker  # 设置开机自启动</span><br><span class="line">systemctl stop docker    # 关闭docker</span><br><span class="line">systemctl restart docker #重启docker</span><br><span class="line">docker version           # 查看当前版本号，是否启动成功</span><br><span class="line">docker info             </span><br></pre></td></tr></table></figure><p>帮助命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker --help        #帮助命令</span><br><span class="line">docker pull --help#拉去images的帮助命令</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/12/QCE3R2dsTkfUOXD.png" alt="image-20221018153437685"></p><p><img src="https://s2.loli.net/2022/11/12/buy8jnRVM7iH3E1.png" alt="image-20221018153525892"></p><p><img src="https://s2.loli.net/2022/11/12/2UtdHErJYP6ZBTm.png" alt="image-20221018153629701"></p><h3 id="3-镜像命令">3.镜像命令</h3><h4 id="3-1查看本地主机镜像">3.1查看本地主机镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line"></span><br><span class="line"># 可选参数</span><br><span class="line">-a/--all 列出所有镜像</span><br><span class="line">-q/--quiet 只显示镜像的id</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/12/5TCax8FbuI6oYLG.png" alt="image-20221018153925224"></p><p><strong>列表参数解释</strong></p><ol><li>REPOSITORY  镜像的仓库源</li><li>TAG  镜像的标签</li><li>IMAGE ID 镜像的id</li><li>CREATED 镜像的创建时间</li><li>SIZE 镜像的大小</li></ol><h4 id="3-2搜索镜像">3.2搜索镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search 镜像名</span><br><span class="line"></span><br><span class="line">#可选参数</span><br><span class="line">Search the Docker Hub for images</span><br><span class="line">Options:</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print search using a Go template</span><br><span class="line">      --limit int       Max number of search results (default 25)</span><br><span class="line">      --no-trunc        Don\&#x27;t truncate output</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/12/2PNqrHjX6nVWeIM.png" alt="img"></p><h4 id="3-3拉取镜像">3.3拉取镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名[:tag]</span><br></pre></td></tr></table></figure><p><strong>关于tag</strong></p><p>默认拉取tag为latest的镜像，即最新版本，当然也可以指定版本。</p><p>这里，涉及到docker镜像<a href="https://docs.docker.com/storage/storagedriver/">“层”和存储驱动的知识</a>。简而言之，一个镜像由许多层组成，如果两个镜像有“层”重复，则不需要重复拉取，节约空间。但是，如果镜像被不同的tag标记，即使它们完全相同（“层”也完全相同，共用一组“层”），docker还是会显示两个images，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#拉取了java的镜像，tag为latest</span><br><span class="line">$ docker pull java</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/java</span><br><span class="line">5040bd298390: Pull complete </span><br><span class="line">fce5728aad85: Pull complete </span><br><span class="line">76610ec20bf5: Pull complete </span><br><span class="line">60170fec2151: Pull complete </span><br><span class="line">e98f73de8f0d: Pull complete </span><br><span class="line">11f7af24ed9c: Pull complete </span><br><span class="line">49e2d6393f32: Pull complete </span><br><span class="line">bb9cdec9c7f3: Pull complete </span><br><span class="line">Digest: sha256:c1ff613e8ba25833d2e1940da0940c3824f03f802c449f3d1815a66b7f8c0e9d</span><br><span class="line">Status: Downloaded newer image for java:latest</span><br><span class="line"></span><br><span class="line">$ docker pull java:8-jdk</span><br><span class="line">8-jdk: Pulling from library/java</span><br><span class="line">Digest: sha256:c1ff613e8ba25833d2e1940da0940c3824f03f802c449f3d1815a66b7f8c0e9d</span><br><span class="line">Status: Downloaded newer image for java:8-jdk</span><br><span class="line"></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY   TAG     IMAGE ID   CREATED    SIZE</span><br><span class="line">java    8-jdk    d23bdf5b1b1b  20 months ago  643MB</span><br><span class="line">java    latest    d23bdf5b1b1b  20 months ago  643MB</span><br></pre></td></tr></table></figure><p>这里java版本8-jdk就是最新的，拉取8-jdk时不需要再拉取重复“层”，但是依然显示不同的images</p><h4 id="3-4删除镜像">3.4删除镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi -f 镜像名/镜像ID                            #删除一个 </span><br><span class="line">docker rmi -f 镜像名/镜像ID 镜像名/镜像ID 镜像名/镜像ID   #删除多个</span><br><span class="line">docker rmi -f $(docker images -aq)                   #删除全部</span><br><span class="line">docker images rm 镜像名称/镜像ID                       #强制删除镜像</span><br></pre></td></tr></table></figure><h3 id="4-容器命令">4.容器命令</h3><h4 id="4-1查看容器">4.1查看容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps     #查看正在运行的容器列表</span><br><span class="line">docker ps -a  #查看所有容器</span><br></pre></td></tr></table></figure><h4 id="4-2运行-停止容器">4.2运行&amp;停止容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line">docker run -itd --name redis002 -p 8888:6379 redis:5.0.5 /bin/bash  #容器端口与服务器端口映射</span><br><span class="line"></span><br><span class="line">#参数说明</span><br><span class="line">--name=&quot;名字&quot;           指定容器名字</span><br><span class="line">-d                     后台方式运行</span><br><span class="line">-it                    使用交互方式运行,进入容器查看内容</span><br><span class="line">-p                     指定容器的端口</span><br><span class="line">( -p ip:主机端口:容器端口  配置主机端口映射到容器端口</span><br><span class="line">  -p 主机端口:容器端口</span><br><span class="line">  -p 容器端口)</span><br><span class="line">-P                     随机指定端口(大写的P)</span><br><span class="line"></span><br><span class="line">-v                     /宿主机目录:/容器目录 挂载宿主机的一个目录。</span><br><span class="line">                       这里把容器想成一个单独的系统，或者说电脑，而你的宿主机目录是一个U盘，挂载                          后，你往宿主机该目录里放文件，那么通过容器里对应目录便可以访问到此文件，不需                        要重新生成容器就可以在“容器外部”添加和修改某些文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop 容器名/容器ID   #停止容器</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span><br><span class="line">runoob@runoob:~$ docker run -it nginx:latest /bin/bash</span><br><span class="line">root@b8573233d675:/# </span><br></pre></td></tr></table></figure><h4 id="4-3删除容器">4.3删除容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm -f 容器名/容器ID  #删除一个</span><br><span class="line">docker rm -f 镜像名/镜像ID 镜像名/镜像ID 镜像名/镜像ID  #删除多个---</span><br><span class="line">docker rmi -f $(docker ps -aq)   #删除全部</span><br></pre></td></tr></table></figure><p><strong>docker生命流程图</strong></p><p><img src="https://s2.loli.net/2022/11/12/XHfZlAz163bv4Wn.png" alt="img"></p><h3 id="5-其他命令">5.其他命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#获取镜像的元信息：</span><br><span class="line">docker inspect 镜像名</span><br><span class="line"></span><br><span class="line">#将容器导出为tar包：</span><br><span class="line">docker export aa93039fd7fa &gt; aa91.tar</span><br><span class="line"></span><br><span class="line">docker export aa9 -o thinkphp6.tar</span><br><span class="line"> </span><br><span class="line">#将tar包导入为镜像：</span><br><span class="line">docker import tp3-where.tar tp3-where:latest</span><br><span class="line"></span><br><span class="line">#使用start.sh方法启动镜像</span><br><span class="line">docker run -d -p 81:80 vul_thinphp6:latest /start.sh</span><br></pre></td></tr></table></figure><h3 id="6-命令的比较">6.命令的比较</h3><h4 id="docker-run和docker-start">docker run和docker start</h4><p>docker run相当于执行了两步操作：将镜像放入容器中（docker create），然后将容器启动，使之变成运行时容器（docker start）。</p><p>而docker start的作用是，重新启动已存在的镜像。也就是说，如果使用这个命令，我们必须事先知道这个容器的ID，或者这个容器的名字，我们可以使用docker ps找到这个容器的信息。</p><h4 id="docker-run和docker-exec">docker run和docker exec</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器名/容器ID /bin/bash   #进入容器</span><br></pre></td></tr></table></figure><p>“docker run”通常是在新创建的容器中所使用的命令。 它适用适合没有容器运行的情况，您想要创建一个容器，并且要启动它，然后在其上运行一个进程。</p><p>“docker exec”适用于在现有容器中运行命令的情况。如果您已经拥有了一个正在运行的容器，并希望更改该容器或从中获取某些内容，那么使用“docker exec”命令就非常合适了。</p><h4 id="docker-kill和docker-stop">docker kill和docker stop</h4><p>相同点：两者都是停掉容器，并把容器状态指定到stopped。</p><p>不同点：<br>被kill杀死容器，进入stopped状态被重新start后，会开启新的进程号；<br>被stop停掉的容器，再次被重新start后，进程号不变，还是原来的。</p><p>kill命令比较生猛，不管容器死活，直接给系统发送SIGKILL的系统信号强行kill掉进程，就是要用kill -9干掉容器；</p><p>stop比较温柔，先给容器发送一个TERM信号，给容器充足时间(默认10秒)保存数据，让容器自动安全停止运行，超时后再给系统发送SIGKILL的系统信号强行kill掉进程，最后转变为stop状态。</p><p>使用docker stop -t [s, default 10],可调整超时时间（docker stop -t 20 mynginx）</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再也不会长大</title>
      <link href="/2022/03/24/22-33-02/"/>
      <url>/2022/03/24/22-33-02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>八十岁之后，我的外婆再也没过过生日。她总说，生日是个槛，人越老越不想过。</p><p>我二十岁之后，日子如白驹过隙，果真，我对自己的生日也没那么期待了。</p><p>今年立冬的凌晨，西安倏尔大雪，这是在江南从未见过的景象。他们说，一片大雪就是一股思念，那我的思念也冻了厚厚的一层吧。</p><p>很久以前在南方，外婆把日历撕下来，整齐的一叠。日历纸很薄，节假日红色，平时绿色。外婆的一天就是一张纸，日日分明。</p><p>年关将近，日历变红的时候，我就能见到外公外婆。那时我七八岁，记忆里总是在月明星稀的夜里走回家。月光下，野荡漆黑的水面泛起点点银光，芦苇婆娑。低头赶路，土路深深浅浅，远处家里一盏昏黄的灯渐渐清晰。屋外无限得冷，可心里却温暖——就要到家啦，那是独属于我的温暖。</p><p>进了院门，外公外婆就会迎出来，拴在门房的黑狗也要扑上来舔我的脸。我们一家在院子里用力地跺脚，抖掉一路的风尘，把那一年所有的辛苦和委屈也都留在门外。家里跛脚的老猫被惊醒，抬头“咪呜”一身，又蜷身睡去。</p><p>夜深了，关灯，我盖上厚厚的棉被，半梦半醒地听我妈和外婆说话。村上的生老病死、悲欢离合，说不清也说不完。隐隐听见远处的火车驶过。我躺在床上，像躺在一条古老的船上。</p><p>外公外婆的家永远不关门。他们的儿女，儿女的儿女，匆匆出现又消失，每年来这聚一下，然后再开枝散叶。我们渐渐长大，外公外婆也老了。</p><p>五年前，外公生了重病，吃不下饭，毫无办法。外婆孤单又无助。妈妈打电话给外婆，让她打米糊、熬中药甚至找偏方，外婆一一照办。外公的起居都靠她一人照料。可是外公还是一日日地病下去。终于有一天，妈妈又打电话嘱咐她，外婆忽然落泪：“我十六岁就嫁到这个家，年轻时照顾你爸的妈，老了又照顾你爸，一辈子……我去给你爸热粥了。”妈妈默然。</p><p>我忽然想起童年时的很多事情，想起了我瘦小的外婆。她从来没有这样脆弱，但她也从来没有缺失过对这个家的爱，她有自己的方式。<br>江湖夜雨十年灯。转眼我就二十一岁了，过了二十岁，我一直在想，怎样才能活得有意义、活得不平凡。我在远远的西安想着这些，想起了许多猝不及防的相遇，想起了许多后知后觉的告别，想起了我的亲人，我的童年。</p><p>我渐渐认识到，一辈子只有一次，爱别人胜过爱自己——虽然就一次，也很不容易。</p><p>长大是一件辛苦的事情，但爱不是。我们都在长大，但我们都忘了给自己一个必须去爱的理由。</p><p>外婆家的院子里有棵硕大的柿子树，秋天到了就结满金黄的柿子。有天我在树下捡到一个小柿子，翠绿、坚硬，一股苦寒香，冒着青春期特有的幼稚和傻气。我把它送给外婆，外婆对我说，它再也不会长大啦。</p><p>它再也不会长大。</p><p><img src="https://s2.loli.net/2022/11/12/O4Wy6HmXJkIqzZC.jpg" alt=""></p><p><img src="https://s2.loli.net/2022/11/12/y8sj7XNTm4IrGdf.png" alt=""></p><blockquote><p>作于2021年11月9日</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西安碎碎念</title>
      <link href="/2022/03/22/22-15-20/"/>
      <url>/2022/03/22/22-15-20/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-ZIDfNQva" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="28587882" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>上大学之前我从来没有离开过常州，十九岁第一次出远门，我就去了西安，往返两千四百公里，穿越大半个中国。</p><p>第一次想去西安是看贾平凹的《废都》，浩大的城装满了文人心事。坐在飞机看，西安不再是那个遥远的城市。确实如此，浩浩荡荡，了无际涯。</p><p>西安最不缺的就是历史和文化。散落在城市大大小小的塔，一千五百年；街上枝叶摇落国槐，一千三百年；爬城墙，随便扣块砖，五百年。和女生去看银杏，买五块钱一把的拐枣，小小的，丑丑的，毫不起眼；十一块的杂肝汤，葱蒜漂满碗；还有臭豆腐，黑白相杂，她不吃辣，我就舀了一点辣酱，卧在盒子一角。</p><p>一直想遇到城墙上吹埙的人，就像《废都》里写的一样。埙里有歌：少年时候遇见你，是在哪一天？</p><p>判断对一个城市的熟悉程度，每个人有自己的标准。可能是知道哪家酒馆的酒又好又便宜，可能是知道哪家饭馆的老板娘很美。</p><p>对我来说，是在这座城市遇到可爱的人。华灯初上的时候，一起走大唐不夜城缓缓的坡，夏天还没到，风还很凉快；秋天去香积寺，看满墙的藤蔓慢慢变黄；晚上，小冷，她给我一个硬硬的猕猴桃，在宿舍放了好久，还是硬，砸脑袋还是疼，捂了好久，心里还是冷。</p><p>朝代更迭，沧海桑田。西安不说话，但是教给我很多东西。千百年了，无数遇见和错过之后，西安城陪我走下去。</p><p>可能许多年之后，我在世界上的某个角落某个夜晚，偶尔看到雾霾，见到金黄的叶，吃到硬硬的猕猴桃，恍惚间又到了太白南路，又成了那个瞻前顾后，执拗的少年。</p><p>西安好大；西安好小。“我无处可逃，就像孙悟空飞不出如来的手掌。”</p><p><img src="https://s2.loli.net/2022/11/11/Mz8w42gdi5frmHJ.jpg" alt=""></p><p><img src="https://s2.loli.net/2022/11/11/AeFHqSL59dDZcNB.png" alt=""></p><blockquote><p>作于2020年12月13日</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 城市 </tag>
            
            <tag> 西安 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重拾破碎故事之心</title>
      <link href="/2020/11/11/01-31-53/"/>
      <url>/2020/11/11/01-31-53/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>又看了一遍塞林格的《破碎故事之心》，小小的一篇字，很喜欢。</p><p>对里面主人公的告白感触颇深：“有人认为爱是性是婚姻，是清晨六点的吻，是一堆孩子，也许真是这样的，莱斯特小姐。但你知道我怎么想吗，我觉得爱是想触碰，又收回手。”</p><p>如果爱情是一场冒险，坠入爱河永远是最容易的部分。一见钟情的概率比白头偕老大很多。爱情的初心不一样，结局就会不一样。</p><p>人生若只如初见，何事秋风悲画扇。</p><p>爱情永远不是一时的决定，是不断重复的抉择。这也就是为什么有些会浓，有些会淡。</p><p>好的感情的开始，也许是一见如故的感觉。黄昏时的初遇，我可以款款地看着她，说，最近几年我过得不好，我从来没有对别人说过，只是遇见你，不知为何我的眼泪就会落。</p><p>就算知道感情终究归于平淡，我还是相信它，还是觉得“金风玉露一相逢，便胜却人间无数”。</p><p>结局如何，我并不急于知晓。</p><p><img src="https://s2.loli.net/2022/11/12/N6oweukmRxWQTJ3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孩子的事</title>
      <link href="/2020/06/13/01-38-06/"/>
      <url>/2020/06/13/01-38-06/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>接触这群小屁孩半个多月，每日与他们厮混，沾点天真的傻气，好像又回到了七八年前，成了那个醉生梦死的小傻逼。</p><p>童年时代，生活本分的摊在眼前，学习就是学习，玩就是玩，还没有成败和功利，了无牵挂。</p><p>再过三个星期，他们会上不同的中学，从此奔赴不同的人生，相忘于江湖。他们未来要经历的一切，都在现在埋下了伏笔。</p><p>小屁孩们不知道，他们今后接受教育的地方，只是学区房或者积分政策分配的结果，是父母的能力和选择，与自己的成绩无关，可是他们还是会为自己未来的中学争辩，还是会对注定的未来憧憬。</p><p>在这种入学模式下，我也未曾幸免，不过是比别人幸运了一点。</p><p>我想，大多数人都是在出演不是自己选择的剧本，站在不是自己选择的舞台上，这个世界本来就有很多不尽人意。人生的开端不能顺意，至少之后，努力做自己，多点可以奋斗终身的信念，就不会被别人的标准束缚或改变。</p><p>我不是、也不可能成为教师，但我觉得教育的意义，永远不是定义孩子或教孩子用身外之物定义别人，而是让他们学会选择，选择自己生活的方式，并为之承担责任。</p><p>我永远相信，态度比聪明重要，信念比环境重要，孩子早点懂这个道理比一切都重要。</p><p>共勉。</p><p><img src="https://s2.loli.net/2022/11/12/N6oweukmRxWQTJ3.png" alt="小标"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教育 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迟到的拳拳离愁</title>
      <link href="/2020/01/30/01-51-00/"/>
      <url>/2020/01/30/01-51-00/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>从老家回来了，洗了个热水澡，钻被窝里，舒坦。</p><p>相比之下，乡下真静。我一个人睡在二楼，听耗子在阁楼上走，歧吱呀呀。恍惚像睡在一条大船上。也只有这样的静，才能消解一天的喧嚣与俗气。</p><p>乡下寂寞，与老辈人没有话说，真要走了，倒有点不舍。外婆招手，车开走，驶了好久回头看，老人家还站在原处。夕阳西下，外婆的暗红棉衣格外显眼。</p><p>二十年了，这与少年时代的无数次离别场景，并没有什么不同。</p><p>小时候离别常哭鼻子，长大了，不知是变得坚强还是麻木，这拳拳离愁，总是迟到。</p><p>这样想想，好像又回到了少年梦多的时候。</p><p>晚安。</p><p><img src="https://s2.loli.net/2022/11/12/N6oweukmRxWQTJ3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
